{
  "src/lib/collections.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.createTemplateTagFirstArg=function(f){return f.raw=f};$jscomp.createTemplateTagFirstArgWithRaw=function(f,l){f.raw=l;return f};$jscomp.arrayIteratorImpl=function(f){var l=0;return function(){return l<f.length?{done:!1,value:f[l++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.makeIterator=function(f){var l=\"undefined\"!=typeof Symbol&&Symbol.iterator&&f[Symbol.iterator];return l?l.call(f):$jscomp.arrayIterator(f)};\nfunction $builtinmodule(f){var l={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),function(p){l._iskeyword=p.$d.iskeyword;return Sk.importModule(\"itertools\",!1,!0)},function(p){l._chain=p.$d.chain;l._starmap=p.$d.starmap;l._repeat=p.$d.repeat;return Sk.importModule(\"operator\",!1,!0)},function(p){l._itemgetter=p.$d.itemgetter},function(){return collections_mod(l)})}\nfunction collections_mod(f){function l(a){return function(b){if(void 0!==b&&!(b instanceof f.Counter))return Sk.builtin.NotImplemented.NotImplemented$;var c=new f.Counter;a.call(this,c,b);return c}}function p(a,b){return function(c){if(!(c instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+a+\"= \"+Sk.abstr.typeName(c)+\" is not supported\");b.call(this,c);return this.keep$positive()}}function v(a,b,c,d,e){function g(m,n){return m.prototype.tp$new(Sk.misceval.arrayFromIterable(n))}\nfunction k(m){for(var n=[],t=0;t<m._fields.v.length;t++)n.push(m._fields.v[t]),n.push(m.v[t]);return new Sk.builtin.dict(n)}function q(m,n){m=new Sk.builtin.dict(m);var t=m.tp$getattr(new Sk.builtin.str(\"pop\")),B=Sk.abstr.gattr(n,new Sk.builtin.str(\"_make\")),y=Sk.misceval.callsimArray;n=y(B,[y(Sk.builtin.map_,[t,z,n])]);if(m.sq$length())throw m=m.sk$asarray(),new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+m.map(function(C){return\"'\"+C.$jsstr()+\"'\"})+\"]\");return n}a=a.tp$str();if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,\n[a])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(a)+\"'\");a=a.$jsstr();if(D.test(a)||!x.test(a)||!a)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+a+\"'\");if(Sk.builtin.checkString(b)){var h=b.$jsstr().replace(E,\" \").split(F);1==h.length&&\"\"===h[0]&&(h=[]);var r=h.map(function(m){return new Sk.builtin.str(m)})}else{h=[];r=[];b=Sk.abstr.iter(b);for(var u=b.tp$iternext();void 0!==u;u=b.tp$iternext())u=\nu.tp$str(),r.push(u),h.push(u.$jsstr())}b=new Set;if(Sk.misceval.isTrue(c))for(c=0;c<h.length;c++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,[r[c]]))||A.test(h[c])||!x.test(h[c])||!h[c]||b.has(h[c]))h[c]=\"_\"+c,r[c]=new Sk.builtin.str(\"_\"+c);b.add(h[c])}else for(c=0;c<h.length;c++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,[r[c]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+h[c]+\"'\");if(A.test(h[c]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+\nh[c]+\"'\");if(!x.test(h[c])||!h[c])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+h[c]+\"'\");if(b.has(h[c]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+h[c]+\"'\");b.add(h[c])}var z=new Sk.builtin.tuple(r);c=[];var w=[];if(!Sk.builtin.checkNone(d)){w=Sk.misceval.arrayFromIterable(d);if(w.length>h.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");d=0;for(b=r.length-w.length;b<r.length;d++,b++)c.push(r[b]),\nc.push(w[d])}d=new Sk.builtin.dict(c);g.co_varnames=[\"_cls\",\"iterable\"];k.co_varnames=[\"self\"];q.co_kwargs=1;q.co_varnames=[\"_self\"];c={};for(b=0;b<h.length;b++)c[r[b].$mangled]=new Sk.builtin.property(new f._itemgetter([new Sk.builtin.int_(b)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+b));return Sk.abstr.buildNativeClass(a,{constructor:function(){},base:Sk.builtin.tuple,slots:{tp$doc:a+\"(\"+h.join(\", \")+\")\",tp$new:function(m,n){m=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",h,m,n,\nw);n=new this.constructor;Sk.builtin.tuple.call(n,m);return n},$r:function(){var m=this.v.map(function(n,t){return h[t]+\"=\"+Sk.misceval.objectRepr(n)});return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+m.join(\", \")+\")\")}},proto:Object.assign({__module__:Sk.builtin.checkNone(e)?Sk.globals.__name__:e,__slots__:new Sk.builtin.tuple,_fields:z,_field_defaults:d,_make:new Sk.builtin.classmethod(new Sk.builtin.func(g)),_asdict:new Sk.builtin.func(k),_replace:new Sk.builtin.func(q)},c)})}f.__all__=new Sk.builtin.list([\"deque\",\n\"defaultdict\",\"namedtuple\",\"Counter\",\"OrderedDict\"].map(function(a){return new Sk.builtin.str(a)}));f.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function(a,b){this.default_factory=a;Sk.builtin.dict.call(this,b)},base:Sk.builtin.dict,methods:{copy:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth:function(a){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(a));\nvar b=Sk.misceval.callsimArray(this.default_factory,[]);this.mp$ass_subscript(a,b);return b},$flags:{OneArg:!0}}},getsets:{default_factory:{$get:function(){return this.default_factory},$set:function(a){this.default_factory=a=a||Sk.builtin.none.none$}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --\\x3e dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",\ntp$init:function(a,b){var c=a.shift();if(void 0===c)this.default_factory=Sk.builtin.none.none$;else if(Sk.builtin.checkCallable(c)||Sk.builtin.checkNone(c))this.default_factory=c;else throw new Sk.builtin.TypeError(\"first argument must be callable\");return Sk.builtin.dict.prototype.tp$init.call(this,a,b)},$r:function(){var a=Sk.misceval.objectRepr(this.default_factory),b=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+a+\", \"+b+\")\")}},proto:{$copy:function(){var a=\nthis,b=[];Sk.misceval.iterFor(Sk.abstr.iter(this),function(c){b.push(c);b.push(a.mp$subscript(c))});return new f.defaultdict(this.default_factory,b)}}});f.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function(){this.$d=new Sk.builtin.dict;Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth:function(){var a=f._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),b=Sk.misceval.callsimArray;return b(a,[b(f._starmap,[f._repeat,b(this.tp$getattr(this.str$items))])])}},\nmost_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},$meth:function(a){var b=this.sq$length();Sk.builtin.checkNone(a)?a=b:(a=Sk.misceval.asIndexOrThrow(a),a=a>b?b:0>a?0:a);b=this.$items().sort(function(c,d){return Sk.misceval.richCompareBool(c[1],d[1],\"Lt\")?1:Sk.misceval.richCompareBool(c[1],d[1],\"Gt\")?-1:0});return new Sk.builtin.list(b.slice(0,a).map(function(c){return new Sk.builtin.tuple(c)}))}},update:{$flags:{FastCall:!0},$meth:function(a,b){Sk.abstr.checkArgsLen(\"update\",\na,0,1);return this.counter$update(a,b)}},subtract:{$flags:{FastCall:!0},$meth:function(a,b){Sk.abstr.checkArgsLen(\"subtract\",a,0,1);a=a[0];if(void 0!==a)if(a instanceof Sk.builtin.dict)for(var c=Sk.abstr.iter(a),d=c.tp$iternext();void 0!==d;d=c.tp$iternext()){var e=this.mp$subscript(d);this.mp$ass_subscript(d,Sk.abstr.numberBinOp(e,a.mp$subscript(d),\"Sub\"))}else for(a=Sk.abstr.iter(a),c=a.tp$iternext();void 0!==c;c=a.tp$iternext())d=this.mp$subscript(c),this.mp$ass_subscript(c,Sk.abstr.numberBinOp(d,\nthis.$one,\"Sub\"));b=b||[];for(a=0;a<b.length;a+=2)c=new Sk.builtin.str(b[a]),d=this.mp$subscript(c),this.mp$ass_subscript(c,Sk.abstr.numberBinOp(d,b[a+1],\"Sub\"));return Sk.builtin.none.none$}},__missing__:{$meth:function(a){return this.$zero},$flags:{OneArg:!0}},copy:{$meth:function(){return Sk.misceval.callsimArray(f.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",\ntp$init:function(a,b){Sk.abstr.checkArgsLen(this.tpjs_name,a,0,1);return this.counter$update(a,b)},$r:function(){var a=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript:function(a,b){return void 0===b?this.mp$lookup(a)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b)},tp$as_number:!0,nb$positive:l(function(a){var b=this;\nthis.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;Sk.misceval.richCompareBool(d,b.$zero,\"Gt\")&&a.mp$ass_subscript(c,d)})}),nb$negative:l(function(a){var b=this;this.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;Sk.misceval.richCompareBool(d,b.$zero,\"Lt\")&&a.mp$ass_subscript(c,Sk.abstr.numberBinOp(b.$zero,d,\"Sub\"))})}),nb$subtract:l(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);\nd=e.next().value;e=e.next().value;e=Sk.abstr.numberBinOp(e,b.mp$subscript(d),\"Sub\");Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;void 0===c.mp$lookup(d)&&Sk.misceval.richCompareBool(e,c.$zero,\"Lt\")&&a.mp$ass_subscript(d,Sk.abstr.numberBinOp(c.$zero,e,\"Sub\"))})}),nb$add:l(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=\ne.next().value;e=Sk.abstr.numberBinOp(e,b.mp$subscript(d),\"Add\");Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;void 0===c.mp$lookup(d)&&Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)})}),nb$inplace_add:p(\"+\",function(a){var b=this;a.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;d=Sk.abstr.numberInplaceBinOp(b.mp$subscript(c),\nd,\"Add\");b.mp$ass_subscript(c,d)})}),nb$inplace_subtract:p(\"-\",function(a){var b=this;a.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;d=Sk.abstr.numberInplaceBinOp(b.mp$subscript(c),d,\"Sub\");b.mp$ass_subscript(c,d)})}),nb$or:l(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;var g=b.mp$subscript(d);e=Sk.misceval.richCompareBool(e,g,\"Lt\")?g:e;Sk.misceval.richCompareBool(e,c.$zero,\n\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;void 0===c.mp$lookup(d)&&Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)})}),nb$and:l(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;var g=b.mp$subscript(d);e=Sk.misceval.richCompareBool(e,g,\"Lt\")?e:g;Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)})}),nb$inplace_and:p(\"&\",\nfunction(a){var b=this;this.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;var e=a.mp$subscript(c);Sk.misceval.richCompareBool(e,d,\"Lt\")&&b.mp$ass_subscript(c,e)})}),nb$inplace_or:p(\"|\",function(a){var b=this;a.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;Sk.misceval.richCompareBool(d,b.mp$subscript(c),\"Gt\")&&b.mp$ass_subscript(c,d)})}),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},\nproto:{keep$positive:function(){var a=this;this.$items().forEach(function(b){var c=$jscomp.makeIterator(b);b=c.next().value;c=c.next().value;Sk.misceval.richCompareBool(c,a.$zero,\"LtE\")&&a.mp$ass_subscript(b)});return this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update:function(a,b){var c=a[0];if(void 0!==c)if(Sk.builtin.checkMapping(c))if(this.sq$length()){a=Sk.abstr.iter(c);for(var d=a.tp$iternext();void 0!==d;d=a.tp$iternext()){var e=\nthis.mp$subscript(d);this.mp$ass_subscript(d,Sk.abstr.numberBinOp(e,c.mp$subscript(d),\"Add\"))}}else this.update$common(a,void 0,\"update\");else for(c=Sk.abstr.iter(c),a=c.tp$iternext();void 0!==a;a=c.tp$iternext())d=this.mp$subscript(a),this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,this.$one,\"Add\"));if(b&&b.length)if(this.sq$length())for(c=0;c<b.length;c+=2)a=new Sk.builtin.str(b[c]),d=this.mp$subscript(a),this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,b[c+1],\"Add\"));else this.update$common([],b,\n\"update\");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\");},$flags:{MinArgs:1,MaxArgs:2}}}});f.OrderedDict=Sk.abstr.buildNativeClass(\"collections.OrderedDict\",{constructor:function(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:\"Dictionary that remembers insertion order\",$r:function(){if(this.in$repr)return new Sk.builtin.str(\"...\");this.in$repr=!0;\nvar a=this.$items().map(function(b){var c=$jscomp.makeIterator(b);b=c.next().value;c=c.next().value;return\"(\"+Sk.misceval.objectRepr(b)+\", \"+Sk.misceval.objectRepr(c)+\")\"});a=0===a.length?\"\":\"[\"+a.join(\", \")+\"]\";this.in$repr=!1;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$richcompare:function(a,b){if(\"Eq\"!==b&&\"Ne\"!==b)return Sk.builtin.NotImplemented.NotImplemented$;if(!(a instanceof f.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,a,b);b=\"Eq\"==b?!0:!1;\nvar c=this.size;if(c!==a.size)return!b;a=a.$items();for(var d=this.$items(),e=0;e<c;e++){var g=d[e],k=a[e],q=g[0],h=k[0];if(q!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(q,h,\"Eq\")))return!b;g=g[1];k=k[1];if(g!==k&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(g,k,\"Eq\")))return!b}return b}},methods:{popitem:{$flags:{NamedArgs:[\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth:function(a){var b=this.get$size();if(0===b)throw new Sk.builtin.KeyError(\"dictionary is empty\");b=$jscomp.makeIterator(this.$items()[Sk.misceval.isTrue(a)?\nb-1:0]);a=b.next().value;b=b.next().value;this.pop$item(a);return new Sk.builtin.tuple([a,b])}},move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth:function(a,b){var c;for(c in this.entries){var d=this.entries[c][0];if(d===a||Sk.misceval.richCompareBool(d,a,\"Eq\")){var e=c;break}}if(void 0===e)throw new Sk.builtin.KeyError(a);a=this.entries[e];delete this.entries[e];Sk.misceval.isTrue(b)?this.entries[e]=a:(b={},this.entries=Object.assign({},(b[e]=a,b),this.entries));\nreturn Sk.builtin.none.none$}}}});f.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function(a,b,c,d,e){this.head=c||0;this.tail=d||0;this.mask=e||1;this.maxlen=b;this.v=a||Array(2)},slots:{tp$doc:\"deque([iterable[, maxlen]]) --\\x3e deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],a,b));\na=b.next().value;b=b.next().value;if(void 0!==b&&!Sk.builtin.checkNone(b)){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError,\"an integer is required\");if(0>b)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");this.maxlen=b}this.$clear();void 0!==a&&this.$extend(a)},tp$getattr:Sk.generic.getAttr,tp$richcompare:function(a,b){if(this===a&&Sk.misceval.opAllowsEquality(b))return!0;if(!(a instanceof f.deque))return Sk.builtin.NotImplemented.NotImplemented$;var c=a,d=this.v;a=a.v;var e=this.tail-\nthis.head&this.mask,g=c.tail-c.head&c.mask,k=Math.max(e,g);if(e===g)for(k=0;k<e&&k<g;++k){var q=Sk.misceval.richCompareBool(d[this.head+k&this.mask],a[c.head+k&c.mask],\"Eq\");if(!q)break}if(k>=e||k>=g)switch(b){case \"Lt\":return e<g;case \"LtE\":return e<=g;case \"Eq\":return e===g;case \"NotEq\":return e!==g;case \"Gt\":return e>g;case \"GtE\":return e>=g}return\"Eq\"===b?!1:\"NotEq\"===b?!0:Sk.misceval.richCompareBool(d[this.head+k&this.mask],a[c.head+k&c.mask],b)},tp$iter:function(){return new G(this)},$r:function(){var a=\n[],b=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(var c=0;c<b;c++)a.push(Sk.misceval.objectRepr(this.v[this.head+c&this.mask]));b=Sk.abstr.typeName(this);if(void 0!==this.maxlen)return new Sk.builtin.str(b+\"([\"+a.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\")\");this.$entered_repr=void 0;return new Sk.builtin.str(b+\"([\"+a.filter(Boolean).join(\", \")+\"])\")},tp$as_number:!0,nb$bool:function(){return 0!==(this.tail-this.head&this.mask)},\ntp$as_sequence_or_mapping:!0,sq$contains:function(a){for(var b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(Sk.misceval.richCompareBool(c,a,\"Eq\"))return!0;return!1},sq$concat:function(a){if(!(a instanceof f.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+Sk.abstr.typeName(a)+\"') to deque\");var b=this.$copy();a=a.tp$iter();for(var c=a.tp$iternext();void 0!==c;c=a.tp$iternext())b.$push(c);return b},sq$length:function(){return this.tail-this.head&this.mask},\nsq$repeat:function(a){a=Sk.misceval.asIndexOrThrow(a,\"can't multiply sequence by non-int of type '{tp$name}'\");var b=this.tail-this.head&this.mask,c=this.$copy();0>=a&&c.$clear();for(var d=1;d<a;d++)for(var e=0;e<b;e++){var g=this.head+e&this.mask;c.$push(this.v[g])}return c},mp$subscript:function(a){a=Sk.misceval.asIndexOrThrow(a);var b=this.tail-this.head&this.mask;if(a>=b||a<-b)throw new Sk.builtin.IndexError(\"deque index out of range\");return this.v[(0<=a?this.head:this.tail)+a&this.mask]},mp$ass_subscript:function(a,\nb){a=Sk.misceval.asIndexOrThrow(a);var c=this.tail-this.head&this.mask;if(a>=c||a<-c)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===b?this.del$item(a):this.set$item(a,b)},nb$inplace_add:function(a){this.maxlen=void 0;a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$push(b);return this},nb$inplace_multiply:function(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\");0>=a&&this.$clear();\nfor(var b=this.$copy(),c=this.tail-this.head&this.mask,d=1;d<a;d++)for(var e=0;e<c;e++)b.$push(this.v[this.head+e&this.mask]);this.v=b.v;this.head=b.head;this.tail=b.tail;this.mask=b.mask;return this}},methods:{append:{$meth:function(a){this.$push(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},appendleft:{$meth:function(a){this.$pushLeft(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},\nclear:{$meth:function(){this.$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},count:{$meth:function(a){for(var b=this.tail-this.head&this.mask,c=0,d=0;d<b;d++)Sk.misceval.richCompareBool(this.v[this.head+\nd&this.mask],a,\"Eq\")&&c++;return new Sk.builtin.int_(c)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth:function(a){this.$extend(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},extendleft:{$meth:function(a){a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$pushLeft(b);return Sk.builtin.none.none$},$flags:{OneArg:!0},\n$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth:function(a,b,c){b=this.$index(a,b,c);if(void 0!==b)return new Sk.builtin.int_(b);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},insert:{$meth:function(a,b){a=Sk.misceval.asIndexOrThrow(a,\"integer argument expected, got {tp$name}\");\nvar c=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&c>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");a>c&&(a=c);a<=-c&&(a=0);a=(0<=a?this.head:this.tail)+a&this.mask;c=this.tail;for(this.tail=this.tail+1&this.mask;c!==a;){var d=c-1&this.mask;this.v[c]=this.v[d];c=d}this.v[a]=b;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);return Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},\npop:{$meth:function(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth:function(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth:function(a){var b=this.$index(a);if(void 0===b)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");for(a=this.head+b&this.mask;a!==this.tail;)b=a+1&this.mask,this.v[a]=this.v[b],a=b;this.tail=this.tail-1&this.mask;\na=this.tail-this.head&this.mask;a<this.mask>>>1&&this.$resize(a,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth:function(){return new H(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth:function(){for(var a=this.head,b=this.tail,c=this.mask,d=this.tail-this.head&this.mask,e=0;e<~~(d/2);e++){var g=b-e-1&c,k=a+e&c,q=this.v[g];this.v[g]=this.v[k];\nthis.v[k]=q}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth:function(a){a=void 0===a?1:Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);var b=this.head,c=this.tail;if(0===a||b===c)return this;this.head=b-a&this.mask;this.tail=c-a&this.mask;if(0<a)for(var d=1;d<=a;d++){var e=c-d&this.mask;this.v[b-d&this.mask]=this.v[e];this.v[e]=void 0}else for(d=0;d>a;d--)e=b-d&this.mask,this.v[c-d&this.mask]=this.v[e],this.v[e]=void 0;return Sk.builtin.none.none$},\n$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},classmethods:Sk.generic.classGetItem,getsets:{maxlen:{$get:function(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear:function(){this.tail=this.head=0;this.mask=1;this.v=Array(2)},$copy:function(){return new f.deque(this.v.slice(0),this.maxlen,this.head,this.tail,\nthis.mask)},$extend:function(a){a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$push(b)},set$item:function(a,b){this.v[(0<=a?this.head:this.tail)+a&this.mask]=b},del$item:function(a){for(a=(0<=a?this.head:this.tail)+a&this.mask;a!==this.tail;){var b=a+1&this.mask;this.v[a]=this.v[b];a=b}a=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask;a<this.mask>>>1&&this.$resize(a,this.v.length>>>1)},$push:function(a){this.v[this.tail]=a;this.tail=this.tail+1&this.mask;\nthis.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$popLeft();return this},$pushLeft:function(a){this.head=this.head-1&this.mask;this.v[this.head]=a;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$pop();return this},$pop:function(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");\nthis.tail=this.tail-1&this.mask;var a=this.v[this.tail];this.v[this.tail]=void 0;var b=this.tail-this.head&this.mask;b<this.mask>>>1&&this.$resize(b,this.v.length>>>1);return a},$popLeft:function(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");var a=this.v[this.head];this.v[this.head]=void 0;this.head=this.head+1&this.mask;var b=this.tail-this.head&this.mask;b<this.mask>>>1&&this.$resize(b,this.v.length>>>1);return a},$resize:function(a,b){var c=this.head,d=this.mask;\nthis.head=0;this.tail=a;this.mask=b-1;if(0===c)this.v.length=b;else{b=Array(b);for(var e=0;e<a;e++)b[e]=this.v[c+e&d];this.v=b}},$index:function(a,b,c){var d=this.tail-this.head&this.mask;b=void 0===b?0:Sk.misceval.asIndexOrThrow(b);c=void 0===c?d:Sk.misceval.asIndexOrThrow(c);var e=this.head,g=this.mask,k=this.v;c=0<=c?c:c<-d?0:d+c;for(b=0<=b?b:b<-d?0:d+b;b<c;b++)if(k[e+b&g]===a)return b},sk$asarray:function(){for(var a=[],b=this.tail-this.head&this.mask,c=0;c<b;++c)a.push(this.v[this.head+c&this.mask]);\nreturn a}}});var G=Sk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function(a){this.$index=0;this.dq=a.v;this.$length=a.tail-a.head&a.mask;this.$head=a.head;this.$tail=a.tail;this.$mask=a.mask},iternext:function(){if(!(this.$index>=this.$length)){var a=(0<=this.$index?this.$head:this.$tail)+this.$index&this.$mask;this.$index++;return this.dq[a]}},methods:{__length_hint__:{$meth:function(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),H=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",\n{constructor:function(a){this.$index=(a.tail-a.head&a.mask)-1;this.dq=a.v;this.$head=a.head;this.$mask=a.mask},iternext:function(){if(!(0>this.$index)){var a=this.$head+this.$index&this.$mask;this.$index--;return this.dq[a]}},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),D=new RegExp(/^[0-9].*/),A=new RegExp(/^[0-9_].*/),x=new RegExp(/^\\w*$/),E=/,/g,F=/\\s+/;v.co_argcount=2;v.co_kwonlyargcount=3;v.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$];\nv.co_varnames=[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"];f.namedtuple=new Sk.builtin.func(v);return f};\n",
  "src/lib/functools.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.createTemplateTagFirstArg=function(e){return e.raw=e};$jscomp.createTemplateTagFirstArgWithRaw=function(e,n){e.raw=n;return e};$jscomp.arrayIteratorImpl=function(e){var n=0;return function(){return n<e.length?{done:!1,value:e[n++]}:{done:!0}}};$jscomp.arrayIterator=function(e){return{next:$jscomp.arrayIteratorImpl(e)}};$jscomp.makeIterator=function(e){var n=\"undefined\"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):$jscomp.arrayIterator(e)};\n$jscomp.arrayFromIterator=function(e){for(var n,y=[];!(n=e.next()).done;)y.push(n.value);return y};$jscomp.arrayFromIterable=function(e){return e instanceof Array?e:$jscomp.arrayFromIterator($jscomp.makeIterator(e))};function $builtinmodule(){var e={};return Sk.misceval.chain(Sk.importModule(\"collections\",!1,!0),function(n){e._namedtuple=n.$d.namedtuple;return functools_mod(e)})}\nfunction functools_mod(e){function n(a){return new m(function(){throw new ha(a+\" is not yet implemented in skulpt\");})}function y(a,b){b||(b=N);if(O(a))a=P(a,Q),0>a&&(a=0);else{if(z(a)&&ia(b)){var c=a;a=128;var d=new G(c,a,b);d.tp$setattr(R,new m(function(){return C({maxsize:a,typed:b})}));return q(e.update_wrapper,[d,c])}if(!S(a))throw new t(\"Expected first argument to be an integer, a callable, or None\");}return new m(function(g){var h=new G(g,a,b);h.tp$setattr(R,new m(function(){return C({maxsize:a,\ntyped:b})}));return q(e.update_wrapper,[h,g])})}function ja(a,b){var c=this,d=T(a,b,this.typed),g=this.cache.mp$lookup(d);if(void 0!==g)return this.hits++,g;this.misses++;return A(q(this.func,a,b),function(h){c.cache.mp$ass_subscript(d,h);return h})}function ka(a,b){this.misses++;return q(this.func,a,b)}function la(a,b){var c=this,d=T(a,b,this.typed),g=this.cache.mp$lookup(d);if(void 0!==g)return a=g.result,U(g),H(this,g),this.hits++,a;this.misses++;return A(q(this.func,a,b),function(h){if(void 0!==\nc.cache.mp$lookup(d))return h;if(c.cache.get$size()<c.maxsize||c.root.next===c.root){var k={key:d,result:h};c.cache.mp$ass_subscript(d,k);H(c,k);return h}k=c.root.next;U(k);if(void 0===c.cache.pop$item(k.key)){h=c.root;var v=h.next;v.prev=h.next=k;k.prev=h;k.next=v;throw new ma(\"cached item removed unexpectedly\");}k.key=d;k.result=h;c.cache.mp$ass_subscript(d,k);H(c,k);return h})}function U(a){var b=a.next;a.prev.next=a.next;b.prev=a.prev}function H(a,b){a=a.root;var c=a.prev;c.next=a.prev=b;b.prev=\nc;b.next=a}function T(a,b,c){var d=a.slice(0),g=[];if(b&&b.length){d.push(na);for(var h=0;h<b.length;h+=2){var k=b[h+1];g.push(k);d.push(new x([new l(b[h]),k]))}}if(V(c))d.push.apply(d,[].concat($jscomp.arrayFromIterable(a.map(function(v){return v.ob$type})),$jscomp.arrayFromIterable(g.map(function(v){return v.ob$type}))));else if(1===d.length&&oa.has(d[0].ob$type))return d[0];return new pa(d)}function W(a,b){a=this.arg_arr.concat(a);if(b){b=X(b);var c=this.kwdict.dict$copy();c.dict$merge(b);b=Y(c)}else b=\nY(this.kwdict);return{args:a,kwargs:b}}function Z(a,b){if(1>a.length)throw new t(\"type 'partial' takes at least 1 argument\");var c=a.shift();if(c instanceof this.sk$builtinBase){var d=c;c=d.fn;var g=d.arg_arr;d=d.kwdict}this.check$func(c);g&&(a=g.concat(a));b=b||[];b=X(b);d&&(g=d.dict$copy(),g.dict$merge(b),b=g);if(this.sk$builtinBase===this.constructor)return new this.constructor(c,a,b);g=new this.constructor;this.sk$builtinBase.call(g,c,a,b);return g}function aa(){if(this.in$repr)return new l(\"...\");\nthis.in$repr=!0;var a=[D(this.fn)];this.arg_arr.forEach(function(b){a.push(D(b))});this.kwdict.$items().forEach(function(b){var c=$jscomp.makeIterator(b);b=c.next().value;c=c.next().value;a.push(b.toString()+\"=\"+D(c))});this.in$repr=!1;return new l(this.tp$name+\"(\"+a.join(\", \")+\")\")}function r(a,b){function c(g,h){var k=I(g.tp$getattr(d),[h]);if(k===qa)return k;k=V(k);return new ra(b(k,g,h))}var d=ba[a];c.co_name=d;return c}var f=Sk.builtin,ca=f.object,J=f.int_,l=f.str,K=f.list,x=f.tuple,E=f.dict,\nF=f.none.none$,N=f.bool.false$,qa=f.NotImplemented.NotImplemented$,ra=f.bool,m=f.func,sa=f.method,t=f.TypeError,ma=f.RuntimeError,ta=f.ValueError,ha=f.NotImplementedError,ua=f.AttributeErrror,Q=f.OverflowError,S=f.checkNone,ia=f.checkBool,z=f.checkCallable,va=f.checkClass;f=Sk.misceval;var I=f.callsimArray,q=f.callsimOrSuspendArray,wa=f.iterFor,A=f.chain,O=f.isIndex,P=f.asIndexSized,V=f.isTrue,u=f.richCompareBool,D=f.objectRepr,C=Sk.ffi.remapToPy,p=Sk.abstr;f=p.buildNativeClass;var xa=p.setUpModuleMethods,\nY=p.keywordArrayFromPyDict,X=p.keywordArrayToPyDict,ya=p.objectHash,za=p.lookupSpecial,da=p.copyKeywordsToNamedArgs,Aa=p.typeName,L=p.iter,ea=p.gattr,w=Sk.generic,B=w.getSetDict;p=w.getAttr;w=w.setAttr;Object.assign(e,{__name__:new l(\"functools\"),__doc__:new l(\"Tools for working with functions and callable objects\"),__all__:new K(\"update_wrapper wraps WRAPPER_ASSIGNMENTS WRAPPER_UPDATES total_ordering cmp_to_key cache lru_cache reduce partial partialmethod singledispatch singledispatchmethod cached_property\".split(\" \").map(function(a){return new l(a)})),\nWRAPPER_ASSIGNMENTS:new x([\"__module__\",\"__name__\",\"__qualname__\",\"__doc__\",\"__annotations__\"].map(function(a){return new l(a)})),WRAPPER_UPDATES:new x([new l(\"__dict__\")]),singledispatch:n(\"singledispatch\"),singledispatchmethod:n(\"singledispatchmethod\"),cached_property:n(\"cached_property\")});var R=new l(\"cache_parameters\"),Ba=e._CacheInfo=I(e._namedtuple,[\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"]].map(function(a){return C(a)}),[\"module\",new l(\"functools\")]),G=f(\"functools._lru_cache_wrapper\",\n{constructor:function(a,b,c,d){if(!z(a))throw new t(\"the first argument must be callable\");if(S(b))d=ja,b=-1;else if(O(b))b=P(b,Q),0>b&&(b=0),d=0===b?ka:la;else throw new t(\"maxsize should be integer or None\");this.root={};this.root.prev=this.root.next=this.root;this.wrapper=d;this.maxsize=b;this.typed=c;this.cache=new E([]);this.func=a;this.misses=this.hits=0;this.$d=new E([])},slots:{tp$new:function(a,b){var c=$jscomp.makeIterator(da(\"_lru_cache_wrapper\",[\"user_function\",\"maxsize\",\"typed\",\"cache_info_type\"],\na,b));a=c.next().value;b=c.next().value;var d=c.next().value;c=c.next().value;return new G(a,b,d,c)},tp$call:function(a,b){return this.wrapper(a,b)},tp$descr_get:function(a,b){return null===a?this:new sa(this,a)},tp$doc:\"Create a cached callable that wraps another function.\\n\\nuser_function:      the function being cached\\n\\nmaxsize:  0         for no caching\\n          None      for unlimited cache size\\n          n         for a bounded cache\\n\\ntyped:    False     cache f(3) and f(3.0) as identical calls\\n          True      cache f(3) and f(3.0) as distinct calls\\n\\ncache_info_type:    namedtuple class with the fields:\\n                        hits misses currsize maxsize\\n\"},\nmethods:{cache_info:{$meth:function(){return q(Ba,[this.hits,this.misses,-1===this.maxsize?F:this.maxsize,this.cache.get$size()].map(function(a){return C(a)}))},$flags:{NoArgs:!0},$doc:\"Report cache statistics\"},cache_clear:{$meth:function(){this.hits=this.misses=0;this.root={};this.root.next=this.root.prev=this.root;return q(this.cache.tp$getattr(new l(\"clear\"),!0))},$flags:{NoArgs:!0},$doc:\"Clear the cache and cache statistics\"},__deepcopy__:{$meth:function(a){return this},$flags:{OneArg:!0}},__copy__:{$meth:function(){return this},\n$flags:{NoArgs:!0}}},getsets:{__dict__:B}}),pa=f(\"_HachedSeq\",{base:K,constructor:function(a){this.$hashval=ya(new x(a));K.call(this,a)},slots:{tp$hash:function(){return this.$hashval}}}),na=new ca,oa=new Set([J,l]);e.partial=f(\"functools.partial\",{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new x(b);this.kwdict=c;this.in$repr=!1;this.$d=new E([])},slots:{tp$new:Z,tp$call:function(a,b){b=this.adj$args_kws(a,b);a=b.args;b=b.kwargs;return this.fn.tp$call(a,b)},tp$doc:\"partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n\",\n$r:aa,tp$getattr:p,tp$setattr:w},getsets:{func:{$get:function(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get:function(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get:function(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:B},methods:{},classmethods:Sk.generic.classGetItem,proto:{adj$args_kws:W,check$func:function(a){if(!z(a))throw new t(\"the first argument must be callable\");\n}}});e.partialmethod=f(\"functools.partialmethod\",{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new x(b);this.kwdict=c},slots:{tp$new:Z,tp$doc:\"Method descriptor with partial application of the given arguments\\n    and keywords.\\n\\n    Supports wrapping existing descriptors and handles non-descriptor\\n    callables as instance methods.\\n    \",$r:aa,tp$descr_get:function(a,b){if(this.fn.tp$descr_get){var c=this.fn.tp$descr_get(a,b);if(c!==this.fn){if(!z(c))throw new t(\"type 'partial' requires a callable\");\nvar d=new e.partial(c,this.arg_arr.slice(0),this.kwdict.dict$copy());c=za(c,this.str$self);void 0!==c&&d.tp$setattr(this.str$self,c)}}void 0===d&&(d=this.make$unbound().tp$descr_get(a,b));return d}},methods:{_make_unbound_method:{$meth:function(){return this.make$unbound()},$flags:{NoArgs:!0}}},classmethods:Sk.generic.classGetItem,getsets:{func:{$get:function(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get:function(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},\nkeywords:{$get:function(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:B},proto:{str$self:new l(\"__self__\"),make$unbound:function(){function a(c,d){var g=c.shift();d=b.adj$args_kws(c,d);c=d.args;d=d.kwargs;c.unshift(g);return q(b.fn,c,d)}var b=this;a.co_fastcall=!0;return new m(a)},adj$args_kws:W,check$func:function(a){if(!z(a)&&void 0===a.tp$descr_get)throw new t(D(a)+\" is not callable or a descriptor\");}}});var ba={__lt__:l.$lt,__le__:l.$le,__gt__:l.$gt,\n__ge__:l.$ge};B=r(\"__lt__\",function(a,b,c){return!a&&u(b,c,\"NotEq\")});w=r(\"__lt__\",function(a,b,c){return a||u(b,c,\"Eq\")});var Ca=r(\"__lt__\",function(a){return!a}),Da=r(\"__le__\",function(a,b,c){return!a||u(b,c,\"Eq\")}),Ea=r(\"__le__\",function(a,b,c){return a&&u(b,c,\"NotEq\")}),Fa=r(\"__le__\",function(a){return!a}),Ga=r(\"__gt__\",function(a,b,c){return!a&&u(b,c,\"NotEq\")}),Ha=r(\"__gt__\",function(a,b,c){return a||u(b,c,\"Eq\")}),Ia=r(\"__gt__\",function(a){return!a}),Ja=r(\"__ge__\",function(a,b,c){return!a||u(b,\nc,\"Eq\")}),Ka=r(\"__ge__\",function(a,b,c){return a&&u(b,c,\"NotEq\")}),La=r(\"__ge__\",function(a){return!a}),fa={__lt__:{__gt__:new m(B),__le__:new m(w),__ge__:new m(Ca)},__le__:{__ge__:new m(Da),__lt__:new m(Ea),__gt__:new m(Fa)},__gt__:{__lt__:new m(Ga),__ge__:new m(Ha),__le__:new m(Ia)},__ge__:{__le__:new m(Ja),__gt__:new m(Ka),__lt__:new m(La)}},Ma={__lt__:\"ob$lt\",__le__:\"ob$le\",__gt__:\"ob$gt\",__ge__:\"ob$ge\"},Na=new J(0),M=f(\"functools.KeyWrapper\",{constructor:function(a,b){this.cmp=a;this.obj=b},\nslots:{tp$call:function(a,b){a=$jscomp.makeIterator(da(\"K\",[\"obj\"],a,b,[])).next().value;return new M(this.cmp,a)},tp$richcompare:function(a,b){if(!(a instanceof M))throw new t(\"other argument must be K instance\");var c=this.obj;a=a.obj;if(!c||!a)throw new ua(\"object\");c=q(this.cmp,[c,a]);return A(c,function(d){return u(d,Na,b)})},tp$getattr:p,tp$hash:F},getsets:{obj:{$get:function(){return this.obj||F},$set:function(a){this.obj=a},$doc:\"Value wrapped by a key function.\"}}}),Oa=new l(\"update\"),Pa=\nnew l(\"__wrapped__\");xa(\"functools\",e,{cache:{$meth:function(a){return q(y(F),[a])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called \"memoize\".',$textsig:\"($module, user_function, /)\"},lru_cache:{$meth:y,$flags:{NamedArgs:[\"maxsize\",\"typed\"],Defaults:[new J(128),N]},$doc:\"Least-recently-used cache decorator.\\n\\nIf *maxsize* is set to None, the LRU features are disabled and the cache\\ncan grow without bound.\\n\\nIf *typed* is True, arguments of different types will be cached separately.\\nFor example, f(3.0) and f(3) will be treated as distinct calls with\\ndistinct results.\\n\\nArguments to the cached function must be hashable.\\n\\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\\nAccess the underlying function with f.__wrapped__.\\n\\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\"},\ncmp_to_key:{$meth:function(a){return new M(a)},$flags:{NamedArgs:[\"mycmp\"],Defaults:[]},$doc:\"Convert a cmp= function into a key= function.\",$textsig:\"($module, cmp, /)\"},reduce:{$meth:function(a,b,c){var d=L(b),g;c=c||d.tp$iternext(!0);return A(c,function(h){if(void 0===h)throw new t(\"reduce() of empty sequence with no initial value\");g=h;return wa(d,function(k){return A(q(a,[g,k]),function(v){g=v})})},function(){return g})},$flags:{MinArgs:2,MaxArgs:3},$doc:\"reduce(function, sequence[, initial]) -> value\\n\\nApply a function of two arguments cumulatively to the items of a sequence,\\nfrom left to right, so as to reduce the sequence to a single value.\\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\nof the sequence in the calculation, and serves as a default when the\\nsequence is empty.\",\n$textsig:\"($module, function, sequence[, initial], /)\"},total_ordering:{$meth:function(a){var b=[];if(!va(a))throw new t(\"total ordering only supported for type objects not '\"+Aa(a)+\"'\");Object.keys(fa).forEach(function(c){var d=Ma[c];a.prototype[d]!==ca.prototype[d]&&b.push(c)});if(!b.length)throw new ta(\"must define atleast one ordering operation: <, >, <=, >=\");Object.entries(fa[b[0]]).forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;b.includes(c)||a.tp$setattr(ba[c],\nd)});return a},$flags:{OneArg:!0},$doc:\"Class decorator that fills in missing ordering methods\"},update_wrapper:{$meth:function(a,b,c,d){c=L(c);for(var g,h=c.tp$iternext();void 0!==h;h=c.tp$iternext())void 0!==(g=b.tp$getattr(h))&&a.tp$setattr(h,g);c=L(d);for(d=c.tp$iternext();void 0!==d;d=c.tp$iternext())g=b.tp$getattr(d)||new E([]),d=ea(a,d),d=ea(d,Oa),I(d,[g]);a.tp$setattr(Pa,b);return a},$flags:{NamedArgs:[\"wrapper\",\"wrapped\",\"assigned\",\"updated\"],Defaults:[e.WRAPPER_ASSIGNMENTS,e.WRAPPER_UPDATES]},\n$doc:\"Update a wrapper function to look like the wrapped function\\n\\n       wrapper is the function to be updated\\n       wrapped is the original function\\n       assigned is a tuple naming the attributes assigned directly\\n       from the wrapped function to the wrapper function (defaults to\\n       functools.WRAPPER_ASSIGNMENTS)\\n       updated is a tuple naming the attributes of the wrapper that\\n       are updated with the corresponding attribute from the wrapped\\n       function (defaults to functools.WRAPPER_UPDATES)\\n    \",\n$textsig:\"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"},wraps:{$meth:function(a,b,c){return q(e.partial,[e.update_wrapper],[\"wrapped\",a,\"assigned\",b,\"updated\",c])},$flags:{NamedArgs:[\"wrapped\",\"assigned\",\"updated\"],Defaults:[e.WRAPPER_ASSIGNMENTS,e.WRAPPER_UPDATES]},$doc:\"Decorator factory to apply update_wrapper() to a wrapper function\\n\\n       Returns a decorator that invokes update_wrapper() with the decorated\\n       function as the wrapper argument and the arguments to wraps() as the\\n       remaining arguments. Default arguments are as for update_wrapper().\\n       This is a convenience function to simplify applying partial() to\\n       update_wrapper().\\n    \",\n$textsig:\"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"}});return e};\n",
  "src/lib/itertools.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(g){var h=0;return function(){return h<g.length?{done:!1,value:g[h++]}:{done:!0}}};$jscomp.arrayIterator=function(g){return{next:$jscomp.arrayIteratorImpl(g)}};$jscomp.makeIterator=function(g){var h=\"undefined\"!=typeof Symbol&&Symbol.iterator&&g[Symbol.iterator];return h?h.call(g):$jscomp.arrayIterator(g)};$jscomp.arrayFromIterator=function(g){for(var h,d=[];!(h=g.next()).done;)d.push(h.value);return d};\n$jscomp.arrayFromIterable=function(g){return g instanceof Array?g:$jscomp.arrayFromIterator($jscomp.makeIterator(g))};\nvar $builtinmodule=function(g){function h(a,b,c){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(a.tp$name,[\"iterable\",\"r\"],b,c,[]));c=b.next().value;b=b.next().value;c=Sk.misceval.arrayFromIterable(c);b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===a)return new a.constructor(c,b);var e=new this.constructor;a.constructor.call(e,c,b);return e}var d={};d.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",\n{constructor:function(a,b,c){var e=this;this.iter=a;this.func=b;this.total=c;this.tp$iternext=function(){e.total=Sk.builtin.checkNone(e.total)?e.iter.tp$iternext():e.total;e.tp$iternext=e.constructor.prototype.tp$iternext;return e.total}},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a)return this.total=Sk.misceval.callsimArray(this.func,[this.total,a])},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --\\x3e accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",\ntp$new:function(a,b){Sk.abstr.checkArgsLen(\"accumulate\",a,0,2);var c=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],a,b,[Sk.builtin.none.none$,Sk.builtin.none.none$]));a=c.next().value;b=c.next().value;c=c.next().value;a=Sk.abstr.iter(a);b=Sk.builtin.checkNone(b)?new Sk.builtin.func(function(f,k){return Sk.abstr.numberBinOp(f,k,\"Add\")}):b;if(this===d.accumulate.prototype)return new d.accumulate(a,b,c);var e=new this.constructor;d.accumulate.call(e,\na,b,c);return e}}});d.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function(a){var b=this;this.iterables=a;this.current_it=null;this.tp$iternext=function(){b.tp$iternext=b.constructor.prototype.tp$iternext;b.current_it=b.iterables.tp$iternext();if(void 0===b.current_it)b.tp$iternext=function(){};else return b.current_it=Sk.abstr.iter(b.current_it),b.tp$iternext()}},iternext:function(a){for(var b;void 0===b;)if(b=this.current_it.tp$iternext(),void 0===b){this.current_it=this.iterables.tp$iternext();\nif(void 0===this.current_it){this.tp$iternext=function(){};break}this.current_it=Sk.abstr.iter(this.current_it)}else return b},slots:{tp$doc:\"chain(*iterables) --\\x3e chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"chain\",b);a=(new Sk.builtin.tuple(a.slice(0))).tp$iter();if(this===d.chain.prototype)return new d.chain(a);\nb=new this.constructor;d.chain.call(b,a);return b}},classmethods:Object.assign({from_iterable:{$meth:function(a){a=Sk.abstr.iter(a);return new d.chain(a)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --\\x3e chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}},Sk.generic.classGetItem)});d.combinations=Sk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;this.indices=\nArray(b).fill().map(function(e,f){return f});this.n=a.length;this.tp$iternext=function(){if(!(c.r>c.n))return c.tp$iternext=c.constructor.prototype.tp$iternext,new Sk.builtin.tuple(c.pool.slice(0,c.r))}},iternext:function(a){var b=this,c=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=a+this.n-this.r){c=!0;break}if(c){this.indices[a]++;for(a+=1;a<this.r;a++)this.indices[a]=this.indices[a-1]+1;a=this.indices.map(function(e){return b.pool[e]});return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations(iterable, r) --\\x3e combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --\\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",\ntp$new:function(a,b){return h.call(this,d.combinations.prototype,a,b)}}});d.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;this.indices=Array(b).fill(0);this.n=a.length;this.tp$iternext=function(){if(!c.r||c.n){c.tp$iternext=c.constructor.prototype.tp$iternext;var e=c.indices.map(function(f){return c.pool[f]});return new Sk.builtin.tuple(e)}}},iternext:function(a){var b=this,c=!1;for(a=\nthis.r-1;0<=a;a--)if(this.indices[a]!=this.n-1){c=!0;break}if(c){for(c=this.indices[a]+1;a<this.r;a++)this.indices[a]=c;a=this.indices.map(function(e){return b.pool[e]});return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --\\x3e combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --\\x3e AA AB AC BB BC CC\",\ntp$new:function(a,b){return h.call(this,d.combinations_with_replacement.prototype,a,b)}}});d.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function(a,b){this.data=a;this.selectors=b},iternext:function(){for(var a=this.data.tp$iternext(),b=this.selectors.tp$iternext();void 0!==a&&void 0!==b;){if(Sk.misceval.isTrue(b))return a;a=this.data.tp$iternext();b=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --\\x3e iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],a,b,[]));a=b.next().value;b=b.next().value;a=Sk.abstr.iter(a);b=Sk.abstr.iter(b);if(this===d.count.prototype)return new d.compress(a,b);var c=new this.constructor;d.compress.call(c,a,b);return c}}});d.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function(a,b){this.start=a;this.step=b},iternext:function(){var a=this.start;this.start=Sk.abstr.numberBinOp(this.start,this.step,\n\"Add\");return a},slots:{tp$doc:\"count(start=0, step=1) --\\x3e count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],a,b,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]));a=b.next().value;b=b.next().value;if(!Sk.builtin.checkNumber(a)&&\n!Sk.builtin.checkComplex(a))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(b)&&!Sk.builtin.checkComplex(b))throw new Sk.builtin.TypeError(\"a number is required\");if(this===d.count.prototype)return new d.count(a,b);var c=new this.constructor;d.count.call(c,a,b);return c},$r:function(){var a=Sk.misceval.objectRepr(this.start),b=Sk.misceval.objectRepr(this.step);b=\"1\"===b?\"\":\", \"+b;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}}});d.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",\n{constructor:function(a){this.iter=a;this.saved=[];this.consumed=!1;this.i=0;this.length},iternext:function(){if(!this.consumed){var a=this.iter.tp$iternext();if(void 0!==a)return this.saved.push(a),a;this.consumed=!0;this.length=this.saved.length;if(!this.length)return}a=this.saved[this.i];this.i=(this.i+1)%this.length;return a},slots:{tp$doc:\"cycle(iterable) --\\x3e cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new:function(a,\nb){Sk.abstr.checkOneArg(\"cycle\",a,b);a=Sk.abstr.iter(a[0]);if(this===d.cycle.prototype)return new d.cycle(a);b=new this.constructor;d.cycle.call(b,a);return b}}});d.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function(a,b){this.predicate=a;this.iter=b;this.passed},iternext:function(){for(var a=this.iter.tp$iternext();void 0===this.passed&&void 0!==a;){var b=Sk.misceval.callsimArray(this.predicate,[a]);if(!Sk.misceval.isTrue(b)){this.passed=!0;break}a=this.iter.tp$iternext()}return a},\nslots:{tp$doc:\"dropwhile(predicate, iterable) --\\x3e dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"dropwhile\",b);Sk.abstr.checkArgsLen(\"dropwhile\",a,2,2);b=a[0];a=Sk.abstr.iter(a[1]);if(this===d.dropwhile.prototype)return new d.dropwhile(b,a);var c=new this.constructor;d.dropwhile.call(c,b,a);return c}}});d.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",\n{constructor:function(a,b){this.predicate=a;this.iter=b},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a){for(var b=Sk.misceval.callsimArray(this.predicate,[a]);Sk.misceval.isTrue(b);){a=this.iter.tp$iternext();if(void 0===a)return;b=Sk.misceval.callsimArray(this.predicate,[a])}return a}},slots:{tp$doc:\"filterfalse(function or None, sequence) --\\x3e filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",\ntp$new:function(a,b){Sk.abstr.checkNoKwargs(\"filterfalse\",b);Sk.abstr.checkArgsLen(\"filterfalse\",a,2,2);b=Sk.builtin.checkNone(a[0])?Sk.builtin.bool:a[0];a=Sk.abstr.iter(a[1]);if(this===d.filterfalse.prototype)return new d.filterfalse(b,a);var c=new this.constructor;d.filterfalse.call(c,b,a);return c}}});d._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function(a,b){this.groupby=a;this.tgtkey=a.tgtkey;this.id=a.id},iternext:function(a){a=Sk.misceval.richCompareBool(this.groupby.currkey,\nthis.tgtkey,\"Eq\");if(this.groupby.id===this.id&&a)return a=this.groupby.currval,this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),a}});d.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function(a,b){this.iter=a;this.keyf=b;this.currval;this.currkey=this.tgtkey=new Sk.builtin.object;this.id},iternext:function(a){this.id={};for(a=Sk.misceval.richCompareBool(this.currkey,\nthis.tgtkey,\"Eq\");a;){this.currval=this.iter.tp$iternext();if(void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]);a=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;a=new d._grouper(this);return new Sk.builtin.tuple([this.currkey,a])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],a,b,[Sk.builtin.none.none$]));a=b.next().value;b=b.next().value;a=Sk.abstr.iter(a);b=Sk.builtin.checkNone(b)?new Sk.builtin.func(function(e){return e}):b;if(this===d.groupby.prototype)return new d.groupby(a,b);var c=new this.constructor;d.groupby.call(c,a,b);return c}}});d.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function(a,b,c,e){var f=this;this.iter=a;this.previt=b;\nthis.stop=c;this.step=e;this.tp$iternext=function(){f.tp$iternext=f.constructor.prototype.tp$iternext;if(f.previt>=f.stop)for(var k=0;k<f.stop;k++)f.iter.tp$iternext();else{for(k=0;k<f.previt;k++)f.iter.tp$iternext();return f.iter.tp$iternext()}}},iternext:function(a){if(this.previt+this.step>=this.stop)for(a=this.previt+1;a<this.stop;a++)this.previt+=this.step,this.iter.tp$iternext();else{for(a=this.previt+1;a<this.previt+this.step;a++)this.iter.tp$iternext();this.previt+=this.step;return this.iter.tp$iternext()}},\nslots:{tp$doc:\"islice(iterable, stop) --\\x3e islice object\\nislice(iterable, start, stop[, step]) --\\x3e islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",tp$new:function(a,\nb){Sk.abstr.checkNoKwargs(\"islice\",b);Sk.abstr.checkArgsLen(\"islice\",a,2,4);b=Sk.abstr.iter(a[0]);var c=a[1],e=a[2];a=a[3];void 0===e?(e=c,a=c=Sk.builtin.none.none$):void 0===a&&(a=Sk.builtin.none.none$);if(Sk.builtin.checkNone(e)||Sk.misceval.isIndex(e)){if(e=Sk.builtin.checkNone(e)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(e),0>e||e>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");\nif(Sk.builtin.checkNone(c)||Sk.misceval.isIndex(c)){if(c=Sk.builtin.checkNone(c)?0:Sk.misceval.asIndexSized(c),0>c||c>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(Sk.builtin.checkNone(a)||Sk.misceval.isIndex(a)){if(a=Sk.builtin.checkNone(a)?1:Sk.misceval.asIndexSized(a),0>=a||a>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");\n}else throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");if(this===d.islice.prototype)return new d.islice(b,c,e,a);var f=new this.constructor;d.islice.call(f,b,c,e,a);return f}}});d.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;var e=a.length;this.indices=Array(e).fill().map(function(f,k){return k});this.cycles=Array(b).fill().map(function(f,k){return e-k});this.n=e;this.tp$iternext=\nfunction(){if(!(c.r>c.n))return c.tp$iternext=c.constructor.prototype.tp$iternext,new Sk.builtin.tuple(c.pool.slice(0,c.r))}},iternext:function(a){var b=this;for(a=this.r-1;0<=a;a--)if(this.cycles[a]--,0==this.cycles[a])this.indices.push(this.indices.splice(a,1)[0]),this.cycles[a]=this.n-a;else{var c=this.cycles[a],e=$jscomp.makeIterator([this.indices[this.n-c],this.indices[a]]);this.indices[a]=e.next().value;this.indices[this.n-c]=e.next().value;a=this.indices.map(function(f){return b.pool[f]}).slice(0,\nthis.r);return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --\\x3e permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --\\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",tp$new:function(a,b){a=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],a,b,[Sk.builtin.none.none$]));b=a.next().value;a=a.next().value;b=Sk.misceval.arrayFromIterable(b);a=Sk.builtin.checkNone(a)?\nb.length:Sk.misceval.asIndexSized(a,Sk.builtin.OverFlowError);if(0>a)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===d.permutations.prototype)return new d.permutations(b,a);var c=new this.constructor;d.permutations.call(c,b,a);return c}}});d.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function(a){var b=this;this.pools=a;this.n=a.length;this.indices=Array(a.length).fill(0);this.pool_sizes=a.map(function(c){return c.length});this.tp$iternext=function(){b.tp$iternext=\nb.constructor.prototype.tp$iternext;var c=b.indices.map(function(e,f){return b.pools[f][b.indices[f]]});if(c.some(function(e){return void 0===e}))b.n=0;else return new Sk.builtin.tuple(c)}},iternext:function(a){var b=this;for(a=this.n-1;0<=a&&a<this.n;)this.indices[a]++,this.indices[a]>=this.pool_sizes[a]?(this.indices[a]=-1,a--):a++;if(!this.n||this.indices.every(function(c){return-1===c}))this.n=0;else return a=this.indices.map(function(c,e){return b.pools[e][b.indices[e]]}),new Sk.builtin.tuple(a)},\nslots:{tp$doc:\"product(*iterables, repeat=1) --\\x3e product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --\\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --\\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],b,[new Sk.builtin.int_(1)])).next().value;b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");for(var c=[],e=0;e<a.length;e++)c.push(Sk.misceval.arrayFromIterable(a[e]));a=[].concat.apply([],$jscomp.arrayFromIterable(Array(b).fill(c)));if(this===d.product.prototype)return new d.product(a);b=new this.constructor;d.product.call(b,\na);return b}}});d.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",{constructor:function(a,b){var c=this;this.object=a;this.times=b;void 0===b&&(this.tp$iternext=function(){return c.object})},iternext:function(a){return 0<this.times--?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",\n[\"object\",\"times\"],a,b,[null]));a=b.next().value;b=b.next().value;b=null!==b?Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError):void 0;if(this===d.repeat.prototype)return new d.repeat(a,b);var c=new this.constructor;d.repeat.call(c,a,b);return c},$r:function(){var a=Sk.misceval.objectRepr(this.object),b=void 0===this.times?\"\":\", \"+(0<=this.times?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}},methods:{__lenght_hint__:{$meth:function(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");\nreturn new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}});d.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",{constructor:function(a,b){this.func=a;this.iter=b},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a)return a=Sk.misceval.arrayFromIterable(a),Sk.misceval.callsimArray(this.func,a)},slots:{tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],a,b,[]));a=b.next().value;b=b.next().value;b=Sk.abstr.iter(b);\na=Sk.builtin.checkNone(a)?Sk.builtin.bool:a;if(this===d.starmap.prototype)return new d.starmap(a,b);var c=new this.constructor;d.starmap.call(c,a,b);return c}}});d.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",{constructor:function(a,b){this.predicate=a;this.iter=b},iternext:function(){var a=this.iter.tp$iternext();if(void 0!==a){var b=Sk.misceval.callsimArray(this.predicate,[a]);if(Sk.misceval.isTrue(b))return a;this.tp$iternext=function(){}}},slots:{tp$doc:\"takewhile(predicate, iterable) --\\x3e takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",\ntp$new:function(a,b){Sk.abstr.checkNoKwargs(\"takewhile\",b);Sk.abstr.checkArgsLen(\"takewhile\",a,2,2);b=a[0];a=Sk.abstr.iter(a[1]);if(this===d.takewhile.prototype)return new d.takewhile(b,a);var c=new this.constructor;d.takewhile.call(c,b,a);return c}}});d.tee=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\");});d.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function(a,b){this.iters=a;this.fillvalue=b;this.active=\nthis.iters.length},iternext:function(a){if(this.active){for(var b=[],c=0;c<this.iters.length;c++){a=this.iters[c].tp$iternext();if(void 0===a){this.active--;if(!this.active)return;this.iters[c]=new d.repeat(this.fillvalue);a=this.fillvalue}b.push(a)}return new Sk.builtin.tuple(b)}},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\\x3e zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],b,[Sk.builtin.none.none$])).next().value;for(var c=[],e=0;e<a.length;e++)c.push(Sk.abstr.iter(a[e]));if(this===d.zip_longest.prototype)return new d.zip_longest(c,b);a=new this.constructor;d.zip_longest.call(a,c,b);return a}}});d.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\");d.__package__=new Sk.builtin.str(\"\");return d};\n",
  "src/lib/keyword.js": "function $builtinmodule(){var a=Sk,b=a.ffi.remapToPy,c=a.builtin;a=c.frozenset;var d=c.str;c=new d(\"keyword\");var f=b([\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]),e=b(\"False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield\".split(\" \"));b=b([\"_\",\"case\",\"match\"]);var g=(new a(e)).tp$getattr(d.$contains);a=(new a(b)).tp$getattr(d.$contains);return{__name__:c,\n__all__:f,kwlist:e,softkwlist:b,iskeyword:g,issoftkeyword:a}};\n",
  "src/lib/math.js": "var $builtinmodule=function(m){function p(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);a=Math.floor(b);if(a!=b)throw new Sk.builtin.ValueError(\"factorial() only accepts integral values\");if(0>a)throw new Sk.builtin.ValueError(\"factorial() not defined for negative numbers\");b=1;for(var c=2;c<=a&&18>=c;c++)b*=c;if(!(18>=a))for(b=JSBI.BigInt(b),c=19;c<=a;c++)b=JSBI.multiply(b,JSBI.BigInt(c));return new Sk.builtin.int_(b)}function n(a,b){function c(e,f){return 0==\nf?e:c(f,e%f)}function d(e,f){return JSBI.equal(f,JSBI.__ZERO)?e:d(f,JSBI.remainder(e,f))}\"number\"===typeof a&&\"number\"===typeof b?(a=Math.abs(a),b=Math.abs(b),a=c(a,b),a=0>a?-a:a):(a=JSBI.BigInt(a),b=JSBI.BigInt(b),a=d(a,b),JSBI.lessThan(a,JSBI.__ZERO)&&(a=JSBI.multiply(a,JSBI.BigInt(-1))));return a}m={pi:new Sk.builtin.float_(Math.PI),e:new Sk.builtin.float_(Math.E),tau:new Sk.builtin.float_(2*Math.PI),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(Infinity)};var l=function(a){return a?\n0>a?-1:1:0>1/a?-1:1};Sk.abstr.setUpModuleMethods(\"math\",m,{acos:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.acos(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc cosine (measured in radians) of x.\"},acosh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log(a+Math.sqrt(a*a-1)))},$flags:{OneArg:!0},\n$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic cosine of x.\"},asin:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.asin(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc sine (measured in radians) of x.\"},asinh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log(a+Math.sqrt(a*a+1)))},\n$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic sine of x.\"},atan:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.atan(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc tangent (measured in radians) of x.\"},atan2:{$meth:function(a,b){Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b));\nreturn new Sk.builtin.float_(Math.atan2(Sk.builtin.asnum$(a),Sk.builtin.asnum$(b)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, y, x, /)\",$doc:\"Return the arc tangent (measured in radians) of y/x.\\n\\nUnlike atan(y/x), the signs of both x and y are considered.\"},atanh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return new Sk.builtin.float_(Math.log((1+a)/(1-a))/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic tangent of x.\"},\nceil:{$meth:function(a){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return Sk.__future__.ceil_floor_int?new Sk.builtin.int_(Math.ceil(a)):new Sk.builtin.float_(Math.ceil(a))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the ceiling of x as an Integral.\\n\\nThis is the smallest integer >= x.\"},comb:{$meth:function(a,b){var c=Sk.misceval.asIndexOrThrow(a),d=Sk.misceval.asIndexOrThrow(b);if(0>c)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");\nif(0>d)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(d>a)return new Sk.builtin.int_(0);a=new Sk.builtin.int_(c);b=new Sk.builtin.int_(d);b=Sk.ffi.remapToJs(a.nb$subtract(b));b<d&&(d=b);if(0===d)return new Sk.builtin.int_(1);if(d>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"min(n - k, k) must not exceed \"+Number.MAX_SAFE_INTEGER);c=new Sk.builtin.int_(1);for(var e=a,f=1;f<d;f++)a=a.nb$subtract(c),b=new Sk.builtin.int_(f+1),e=e.nb$multiply(a),e=e.nb$floor_divide(b);\nreturn e},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.\"},copysign:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));b=Sk.builtin.asnum$(b);a=Sk.builtin.asnum$(a);var c=l(a);b=l(b);return new Sk.builtin.float_(a*c*b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return a float with the magnitude (absolute value) of x but the sign of y.\\n\\nOn platforms that support signed zeros, copysign(1.0, -0.0)\\nreturns -1.0.\\n\"},cos:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));\nreturn new Sk.builtin.float_(Math.cos(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the cosine of x (measured in radians).\"},cosh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);a=Math.pow(Math.E,a);return new Sk.builtin.float_((a+1/a)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic cosine of x.\"},degrees:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));\na=180/Math.PI*Sk.builtin.asnum$(a);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from radians to degrees.\"},erf:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.erf() is not yet implemented in Skulpt\");},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Error function at x.\"},erfc:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.erfc() is not yet implemented in Skulpt\");},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",\n$doc:\"Complementary error function at x.\"},exp:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=a.v;\"number\"!==typeof b&&(b=a.nb$float().v);if(Infinity==b||-Infinity==b||isNaN(b))return new Sk.builtin.float_(Math.exp(b));a=Math.exp(b);if(!isFinite(a))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return e raised to the power of x.\"},expm1:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(.7>Math.abs(a)){var b=Math.exp(a);return 1==b?new Sk.builtin.float_(a):new Sk.builtin.float_((b-1)*a/Math.log(b))}return new Sk.builtin.float_(Math.exp(a)-1)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return exp(x)-1.\\n\\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\"},fabs:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=a.v;JSBI.__isBigInt(b)&&\n(b=a.nb$float().v);b=Math.abs(b);return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the absolute value of the float x.\"},factorial:{$meth:p,$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Find x!.\\n\\nRaise a ValueError if x is negative or non-integral.\"},floor:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));return Sk.__future__.ceil_floor_int?new Sk.builtin.int_(Math.floor(Sk.builtin.asnum$(a))):new Sk.builtin.float_(Math.floor(Sk.builtin.asnum$(a)))},\n$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the floor of x as an Integral.\\n\\nThis is the largest integer <= x.\"},fmod:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));var c=a.v,d=b.v;\"number\"!==typeof c&&(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if((Infinity==d||-Infinity==d)&&isFinite(c))return new Sk.builtin.float_(c);a=c%d;if(isNaN(a)&&!isNaN(c)&&!isNaN(d))throw new Sk.builtin.ValueError(\"math domain error\");\nreturn new Sk.builtin.float_(a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return fmod(x, y), according to platform C.\\n\\nx % y may differ.\"},frexp:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);var b=[a,0];if(0!==a&&Number.isFinite(a)){var c=Math.abs(a),d=Math.max(-1023,Math.floor(Math.log2(c))+1);for(c*=Math.pow(2,-d);.5>c;)c*=2,d--;for(;1<=c;)c*=.5,d++;0>a&&(c=-c);b[0]=c;b[1]=d}b[0]=new Sk.builtin.float_(b[0]);b[1]=\nnew Sk.builtin.int_(b[1]);return new Sk.builtin.tuple(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the mantissa and exponent of x, as pair (m, e).\\n\\nm is a float and e is an int, such that x = m * 2.**e.\\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.\"},fsum:{$meth:function(a){if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(a)+\"' object is not iterable\");var b=[];a=Sk.abstr.iter(a);var c;for(c=a.tp$iternext();void 0!==c;c=a.tp$iternext()){Sk.builtin.pyCheckType(\"\",\n\"real number\",Sk.builtin.checkNumber(c));var d=0;var e=c.v;\"number\"!==typeof e&&(e=c.nb$float().v);c=e;e=0;for(var f=b.length;e<f;e++){var g=b[e];if(Math.abs(c)<Math.abs(g)){var h=c;c=g;g=h}h=c+g;if(c=g-(h-c))b[d]=c,d++;c=h}b=b.slice(0,d).concat([c])}a=b.reduce(function(k,q){return k+q},0);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, seq, /)\",$doc:\"Return an accurate floating point sum of values in the iterable seq.\\n\\nAssumes IEEE-754 floating point arithmetic.\"},gamma:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.gamma() is not yet implemented in Skulpt\");\n},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Gamma function at x.\"},gcd:{$meth:function(a,b){Sk.builtin.pyCheckType(\"a\",\"integer\",Sk.builtin.checkInt(a));Sk.builtin.pyCheckType(\"b\",\"integer\",Sk.builtin.checkInt(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);b=n(a,b);return\"number\"===typeof b?new Sk.builtin.int_(b):new Sk.builtin.int_(b.toString())},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"greatest common divisor of x and y\"},hypot:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(Math.sqrt(a*a+b*b))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return the Euclidean distance, sqrt(x*x + y*y).\"},isclose:{$meth:function(a,b){Sk.abstr.checkArgsLen(\"isclose\",a,2,2);var c=Sk.abstr.copyKeywordsToNamedArgs(\"isclose\",[\"rel_tol\",\"abs_tol\"],[],b,[new Sk.builtin.float_(1E-9),new Sk.builtin.float_(0)]);\nb=a[0];var d=a[1];a=c[0];c=c[1];Sk.builtin.pyCheckType(\"a\",\"number\",Sk.builtin.checkNumber(b));Sk.builtin.pyCheckType(\"b\",\"number\",Sk.builtin.checkNumber(d));Sk.builtin.pyCheckType(\"rel_tol\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"abs_tol\",\"number\",Sk.builtin.checkNumber(c));b=Sk.builtin.asnum$(b);d=Sk.builtin.asnum$(d);a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);if(0>a||0>c)throw new Sk.builtin.ValueError(\"tolerances must be non-negative\");if(b==d)return Sk.builtin.bool.true$;\nif(Infinity==b||-Infinity==b||Infinity==d||-Infinity==d)return Sk.builtin.bool.false$;var e=Math.abs(d-b);return new Sk.builtin.bool(e<=Math.abs(a*d)||e<=Math.abs(a*b)||e<=c)},$flags:{FastCall:!0},$textsig:\"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)\",$doc:'Determine whether two floating point numbers are close in value.\\n\\n  rel_tol\\n    maximum difference for being considered \"close\", relative to the\\n    magnitude of the input values\\n  abs_tol\\n    maximum difference for being considered \"close\", regardless of the\\n    magnitude of the input values\\n\\nReturn True if a is close in value to b, and False otherwise.\\n\\nFor the values to be considered close, the difference between them\\nmust be smaller than at least one of the tolerances.\\n\\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\\nis, NaN is not close to anything, even itself.  inf and -inf are\\nonly close to themselves.'},\nisfinite:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?Sk.builtin.bool.true$:isFinite(b)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"},isinf:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?Sk.builtin.bool.false$:\nisFinite(b)||isNaN(b)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a positive or negative infinity, and False otherwise.\"},isnan:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);return isNaN(a)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a NaN (not a number), and False otherwise.\"},isqrt:{$meth:function(a){a=\nSk.misceval.asIndexOrThrow(a);if(0>a)throw new Sk.builtin.ValueError(\"isqrt() argument must be nonnegative\");if(0==a)return new Sk.builtin.int_(0);if(\"number\"===typeof a)return new Sk.builtin.int_(Math.floor(Math.sqrt(a)));var b=a.toString(2).length;b=Math.floor((b-1)/2);var c=b.toString(2).length,d=JSBI.BigInt(1),e=JSBI.BigInt(2);b=JSBI.BigInt(b);e=JSBI.multiply(e,b);for(var f=d,g=JSBI.BigInt(0);0<c;){c--;var h=g;g=JSBI.signedRightShift(b,JSBI.BigInt(c));var k=JSBI.subtract(JSBI.subtract(g,h),d);\nk=JSBI.leftShift(f,k);h=JSBI.add(JSBI.subtract(JSBI.subtract(e,h),g),d);h=JSBI.signedRightShift(a,h);f=JSBI.add(k,JSBI.divide(h,f))}c=f;JSBI.greaterThan(JSBI.multiply(c,c),a)&&(c=JSBI.subtract(c,d));JSBI.lessThanOrEqual(c,JSBI.BigInt(Number.MAX_SAFE_INTEGER))&&(c=Number(c));return new Sk.builtin.int_(c)},$flags:{OneArg:!0},$textsig:\"($module, n, /)\",$doc:\"Return the integer part of the square root of the input.\"},lcm:{$meth:function(a){for(var b=[],c=0;c<arguments.length;++c)b[c-0]=arguments[c];c=\nfunction(k){return\"number\"===typeof k?new Sk.builtin.int_(Math.abs(k)):JSBI.lessThan(k,JSBI.__ZERO)?new Sk.builtin.int_(JSBI.unaryMinus(k)):new Sk.builtin.int_(k)};var d=b.length;if(0===d)return new Sk.builtin.int_(1);var e;for(e=0;e<d;++e)b[e]=Sk.misceval.asIndexOrThrow(b[e]);var f=b[0];if(1===d)return c(f);for(e=1;e<d;++e){var g=b[e];if(0===g)return new Sk.builtin.int_(0);if(\"number\"===typeof f&&\"number\"===typeof g){var h=f/n(f,g)*g;h=Math.abs(h);f=h>Number.MAX_SAFE_INTEGER?JSBI.BigInt(f):h}else f=\nJSBI.BigInt(f);\"number\"!==typeof f&&(g=JSBI.BigInt(g),f=JSBI.multiply(JSBI.divide(f,n(f,g)),g))}return c(f)},$flags:{MinArgs:0},$textsig:\"($module, *integers, /)\",$doc:\"Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is 0. lcm() without arguments returns 1.\"},ldexp:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"i\",\"integer\",Sk.builtin.checkInt(b));var c=a.v;\"number\"!==typeof c&&(c=a.nb$float().v);a=Sk.builtin.asnum$(b);if(Infinity==c||-Infinity==c||0==c||isNaN(c))return new Sk.builtin.float_(c);c*=Math.pow(2,a);if(!isFinite(c))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(c)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, i, /)\",$doc:\"Return x * (2**i).\\n\\nThis is essentially the inverse of frexp().\"},\nlgamma:{$meth:function(a){throw new Sk.builtin.NotImplementedError(\"math.lgamma() is not yet implemented in Skulpt\");},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Natural logarithm of absolute value of Gamma function at x.\"},log:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var c=Sk.builtin.asnum$(a);if(0>=c)throw new Sk.builtin.ValueError(\"math domain error\");void 0===b?b=Math.E:(Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(b)),b=Sk.builtin.asnum$(b));\nif(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");Sk.builtin.checkFloat(a)||c<Number.MAX_SAFE_INTEGER?c=Math.log(c)/Math.log(b):(c=(new Sk.builtin.str(a)).$jsstr(),a=c.length,c=parseFloat(\"0.\"+c),c=(a*Math.log(10)+Math.log(c))/Math.log(b));return new Sk.builtin.float_(c)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:\"log(x, [base=e])\\nReturn the logarithm of x to the given base.\\n\\nIf the base not specified, returns the natural logarithm (base e) of x.\"},log10:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\n\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);if(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");Sk.builtin.checkFloat(a)||b<Number.MAX_SAFE_INTEGER?b=Math.log10(b):(b=(new Sk.builtin.str(a)).$jsstr(),a=b.length,b=parseFloat(\"0.\"+b),b=a+Math.log10(b));return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 10 logarithm of x.\"},log1p:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=a.v;\"number\"!==\ntypeof b&&(b=a.nb$float().v);if(-1>=b)throw new Sk.builtin.ValueError(\"math domain error\");return 0==b||Math.abs(b)<Number.EPSILON/2?new Sk.builtin.float_(b):-.5<=b&&1>=b?(a=1+b,new Sk.builtin.float_(Math.log(a)-(a-1-b)/a)):new Sk.builtin.float_(Math.log(1+b))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the natural logarithm of 1+x (base e).\\n\\nThe result is computed in a way which is accurate for x near zero.\"},log2:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));\nvar b=Sk.builtin.asnum$(a);if(0>=b)throw new Sk.builtin.ValueError(\"math domain error\");Sk.builtin.checkFloat(a)||b<Number.MAX_SAFE_INTEGER?b=Math.log2(b):(b=(new Sk.builtin.str(a)).$jsstr(),a=b.length,b=parseFloat(\"0.\"+b),b=a*Math.log2(10)+Math.log2(b));return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 2 logarithm of x.\"},modf:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(!isFinite(a)){if(Infinity==\na)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(a)]);if(-Infinity==a)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),new Sk.builtin.float_(a)]);if(isNaN(a))return new Sk.builtin.tuple([new Sk.builtin.float_(a),new Sk.builtin.float_(a)])}var b=l(a);a=Math.abs(a);var c=b*Math.floor(a);return new Sk.builtin.tuple([new Sk.builtin.float_(b*(a-Math.floor(a))),new Sk.builtin.float_(c)])},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the fractional and integer parts of x.\\n\\nBoth results carry the sign of x and are floats.\"},\nperm:{$meth:function(a,b){if(void 0===b||Sk.builtin.checkNone(b))return p(a);a=Sk.misceval.asIndexOrThrow(a);b=Sk.misceval.asIndexOrThrow(b);if(0>a)throw new Sk.builtin.ValueError(\"n must be an non-negative integer\");if(0>b)throw new Sk.builtin.ValueError(\"k must be a non-negative integer\");if(b>a)return new Sk.builtin.int_(0);if(0===b)return new Sk.builtin.int_(1);if(b>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError(\"k must not exceed \"+Number.MAX_SAFE_INTEGER);for(var c=new Sk.builtin.int_(1),\nd=a=new Sk.builtin.int_(a),e=1;e<b;e++)a=a.nb$subtract(c),d=d.nb$multiply(a);return d},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, n, k=None, /)\",$doc:\"'Number of ways to choose k items from n items without repetition and with order.\\n\\nEvaluates to n! / (n - k)! when k <= n and evaluates\\nto zero when k > n.\\n\\nIf k is not specified or is None, then k defaults to n\\nand the function returns n!.\\n\\nRaises TypeError if either of the arguments are not integers.\\nRaises ValueError if either of the arguments are negative.'\"},\nprod:{$meth:function(a,b){function c(){return Sk.misceval.iterFor(f,function(h){if(h.constructor===Sk.builtin.int_)g=g.nb$multiply(h);else{if(h.constructor===Sk.builtin.float_)return g=g.nb$float().nb$multiply(h),new Sk.misceval.Break(\"float\");g=Sk.abstr.numberBinOp(g,h,\"Mult\");return new Sk.misceval.Break(\"slow\")}})}function d(){return Sk.misceval.iterFor(f,function(h){if(h.constructor===Sk.builtin.float_||h.constructor===Sk.builtin.int_)g=g.nb$multiply(h);else return g=Sk.abstr.numberBinOp(g,h,\n\"Mult\"),new Sk.misceval.Break(\"slow\")})}function e(){return Sk.misceval.iterFor(f,function(h){g=Sk.abstr.numberBinOp(g,h,\"Mult\")})}Sk.abstr.checkArgsLen(\"prod\",a,1,1);a=Sk.abstr.copyKeywordsToNamedArgs(\"prod\",[null,\"start\"],a,b,[new Sk.builtin.int_(1)]);var f=Sk.abstr.iter(a[0]),g=a[1];a=g.constructor===Sk.builtin.int_?c():g.constructor===Sk.builtin.float_?\"float\":\"slow\";return Sk.misceval.chain(a,function(h){return\"float\"===h?d():h},function(h){if(\"slow\"===h)return e()},function(){return g})},$flags:{FastCall:!0},\n$textsig:\"($module, iterable, /, *, start=1)\",$doc:\"Calculate the product of all the elements in the input iterable. The default start value for the product is 1.\\n\\nWhen the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.\"},pow:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));var c=a.v,d=b.v;\"number\"!==typeof c&&\n(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if(0==c&&0>d)throw new Sk.builtin.ValueError(\"math domain error\");if(1==c)return new Sk.builtin.float_(1);if(Number.isFinite(c)&&Number.isFinite(d)&&0>c&&!Number.isInteger(d))throw new Sk.builtin.ValueError(\"math domain error\");if(-1==c&&(-Infinity==d||Infinity==d))return new Sk.builtin.float_(1);a=Math.pow(c,d);if(Number.isFinite(c)&&Number.isFinite(d)&&(Infinity==a||-Infinity==a))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(a)},\n$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return x**y (x to the power of y).\"},radians:{$meth:function(a){Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(a));a=Math.PI/180*Sk.builtin.asnum$(a);return new Sk.builtin.float_(a)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from degrees to radians.\"},remainder:{$meth:function(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));\nvar c=a.v,d=b.v;\"number\"!==typeof c&&(c=a.nb$float().v);\"number\"!==typeof d&&(d=b.nb$float().v);if(isFinite(c)&&isFinite(d)){if(0==d)throw new Sk.builtin.ValueError(\"math domain error\");a=Math.abs(c);d=Math.abs(d);var e=a%d;b=d-e;if(e<b)a=e;else if(e>b)a=-b;else{if(e!=b)throw new Sk.builtin.AssertionError;a=e-.5*(a-e)%d*2}return new Sk.builtin.float_(l(c)*a)}if(isNaN(c))return a;if(isNaN(d))return b;if(Infinity==c||-Infinity==c)throw new Sk.builtin.ValueError(\"math domain error\");if(Infinity!=d&&\n-Infinity!=d)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(c)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Difference between x and the closest integer multiple of y.\\n\\nReturn x - n*y where n*y is the closest integer multiple of y.\\nIn the case where x is exactly halfway between two multiples of\\ny, the nearest even value of n is used. The result is always exact.\"},sin:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.sin(Sk.builtin.asnum$(a)))},\n$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the sine of x (measured in radians).\"},sinh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);a=Math.pow(Math.E,a);return new Sk.builtin.float_((a-1/a)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic sine of x.\"},sqrt:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(0>a)throw new Sk.builtin.ValueError(\"math domain error\");\nreturn new Sk.builtin.float_(Math.sqrt(a))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the square root of x.\"},tan:{$meth:function(a){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));return new Sk.builtin.float_(Math.tan(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the tangent of x (measured in radians).\"},tanh:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);if(0===a)return new Sk.builtin.float_(a);\na=Math.pow(Math.E,a);var b=1/a;return new Sk.builtin.float_((a-b)/2/((a+b)/2))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic tangent of x.\"},trunc:{$meth:function(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));return Sk.builtin.checkInt(a)?a:new Sk.builtin.int_(Sk.builtin.asnum$(a)|0)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Truncates the Real x to the nearest Integral toward 0.\\n\\nUses the __trunc__ magic method.\"}});return m};\n",
  "src/lib/operator.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.createTemplateTagFirstArg=function(f){return f.raw=f};$jscomp.createTemplateTagFirstArgWithRaw=function(f,c){f.raw=c;return f};$jscomp.arrayIteratorImpl=function(f){var c=0;return function(){return c<f.length?{done:!1,value:f[c++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.makeIterator=function(f){var c=\"undefined\"!=typeof Symbol&&Symbol.iterator&&f[Symbol.iterator];return c?c.call(f):$jscomp.arrayIterator(f)};\n$jscomp.arrayFromIterator=function(f){for(var c,d=[];!(c=f.next()).done;)d.push(c.value);return d};$jscomp.arrayFromIterable=function(f){return f instanceof Array?f:$jscomp.arrayFromIterator($jscomp.makeIterator(f))};\nfunction $builtinmodule(f){function c(a,b){return Object.assign({},{$meth:a,$doc:b},M[a.length])}function d(a){return\"Same as \"+a+\".\"}var r=Sk,h=r.builtin,t=h.str,F=h.tuple;f=h.list;var G=h.int_,p=h.bool,v=h.TypeError,N=h.ValueError,H=h.none.none$,O=h.NotImplemented.NotImplemented$,P=h.abs,Q=h.len,I=h.checkString,J=h.checkInt,g=r.abstr;h=g.buildNativeClass;var K=g.checkNoKwargs,A=g.checkArgsLen,B=g.checkOneArg,x=g.numberUnaryOp,m=g.numberBinOp,n=g.numberInplaceBinOp,C=g.objectGetItem,R=g.objectDelItem,\nS=g.objectSetItem,T=g.sequenceConcat,U=g.sequenceContains,V=g.sequenceGetCountOf,W=g.sequenceGetIndexOf,X=g.sequenceInPlaceConcat,L=g.typeName,Y=g.lookupSpecial,D=g.gattr;g=g.setUpModuleMethods;var q=r.misceval,u=q.richCompareBool,Z=q.asIndexOrThrow,z=q.chain,aa=q.callsimArray,ba=q.callsimOrSuspendArray,y=q.objectRepr;r=r.generic.getAttr;q=\"abs add and_ concat contains delitem eq floordiv ge getitem gt iadd iand iconcat ifloordiv ilshift imatmul imod imul index inv invert ior ipow irshift isub itruediv ixor le lshift lt matmul mod mul ne neg not_ or_ pos pow rshift setitem sub truediv xor\".split(\" \");\nvar ca=\"attrgetter countOf indexOf is_ is_not itemgetter length_hint methodcaller truth\".split(\" \").concat($jscomp.arrayFromIterable(q)).sort(),l={__name__:new t(\"operator\"),__doc__:new t(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),\n__all__:new f(ca.map(function(a){return new t(a)}))};l.itemgetter=h(\"operator.itemgetter\",{constructor:function(a){this.items=a;this.oneitem=1===a.length;this.item=a[0];this.in$repr=!1},slots:{tp$getattr:r,tp$new:function(a,b){K(\"itemgetter\",b);A(\"itemgetter\",a,1);return new l.itemgetter(a)},tp$call:function(a,b){B(\"itemgetter\",a,b);var e=a[0];return this.oneitem?C(e,this.item,!0):new F(this.items.map(function(k){return C(e,k)}))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",\n$r:function(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;var a=this.tp$name+\"(\"+this.items.map(function(b){return y(b)}).join(\", \")+\")\";this.in$repr=!1;return a}}});l.attrgetter=h(\"operator.attrgetter\",{constructor:function(a){this.attrs=a;this.oneattr=1===a.length;this.attr=a[0];this.in$repr=!1},slots:{tp$getattr:r,tp$new:function(a,b){K(\"attrgetter\",b);A(\"attrgetter\",a,1);b=[];for(var e=0;e<a.length;e++){var k=a[e];if(!I(k))throw new v(\"attribute name must be a string\");\nvar w=k.toString();w.includes(\".\")?b.push(w.split(\".\").map(function(E){return new t(E)})):b.push([k])}return new l.attrgetter(b)},tp$call:function(a,b){B(\"attrgetter\",a,b);var e=a[0];if(this.oneattr)return this.attr.reduce(function(k,w){return D(k,w)},e);a=this.attrs.map(function(k){return k.reduce(function(w,E){return D(w,E)},e)});return new F(a)},tp$doc:\"attrgetter(attr, ...) --\\x3e attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",\n$r:function(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;var a=this.tp$name+\"(\"+this.items.map(function(b){return y(b)}).join(\", \")+\")\";this.in$repr=!1;return a}}});l.methodcaller=h(\"operator.methodcaller\",{constructor:function(a,b,e){this.$name=a;this.args=b;this.kwargs=e||[];this.in$repr=!1},slots:{tp$getattr:r,tp$new:function(a,b){A(\"methodcaller\",a,1);var e=a[0];if(!I(e))throw new v(\"method name must be a string\");return new l.methodcaller(e,a.slice(1),b)},tp$call:function(a,\nb){var e=this;B(\"methodcaller\",a,b);return z(D(a[0],this.$name,!0),function(k){return ba(k,e.args,e.kwargs)})},tp$doc:\"methodcaller(name, ...) --\\x3e methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",$r:function(){if(this.in$repr)return new t(this.tp$name+\"(...)\");this.in$repr=!0;var a=[y(this.$name)];\na.push.apply(a,$jscomp.arrayFromIterable(this.args.map(function(e){return y(e)})));for(var b=0;b<this.kwargs.length;b+=2)a.push(this.kwargs[b]+\"=\"+y(this.kwargs[b+1]));a=this.tp$name+\"(\"+a.join(\", \")+\")\";this.in$repr=!1;return a}}});var M={1:{$flags:{OneArg:!0},$textsig:\"($module, a, /)\"},2:{$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\"},3:{$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\"}};g(\"operator\",l,{lt:c(function(a,b){return p(u(a,b,\"Lt\"))},d(\"a < b\")),le:c(function(a,\nb){return p(u(a,b,\"LtE\"))},d(\"a <= b\")),eq:c(function(a,b){return p(u(a,b,\"Eq\"))},d(\"a == b\")),ne:c(function(a,b){return p(u(a,b,\"NotEq\"))},d(\"a != b\")),ge:c(function(a,b){return p(u(a,b,\"GtE\"))},d(\"a >= b\")),gt:c(function(a,b){return p(u(a,b,\"Gt\"))},d(\"a > b\")),not_:c(function(a){return x(a,\"Not\")},d(\"not a\")),truth:c(function(a){return p(a)},\"Return True if a is true, False otherwise.\"),is_:c(function(a,b){return p(u(a,b,\"Is\"))},d(\"a is b\")),is_not:c(function(a,b){return p(u(a,b,\"IsNot\"))},d(\"a is not b\")),\nabs:c(function(a){return P(a)},d(\"abs(a)\")),add:c(function(a,b){return m(a,b,\"Add\")},d(\"a + b\")),and_:c(function(a,b){return m(a,b,\"BitAnd\")},d(\"a & b\")),floordiv:c(function(a,b){return m(a,b,\"FloorDiv\")},d(\"a // b\")),index:c(function(a){return new G(Z(a))},d(\"a.__index__()\")),inv:c(function(a){return x(a,\"Invert\")},d(\"~a\")),invert:c(function(a){return x(a,\"Invert\")},d(\"~a\")),lshift:c(function(a,b){return m(a,b,\"LShift\")},d(\"a << b\")),mod:c(function(a,b){return m(a,b,\"Mod\")},d(\"a % b\")),mul:c(function(a,\nb){return m(a,b,\"Mult\")},d(\"a * b\")),matmul:c(function(a,b){return m(a,b,\"MatMult\")},d(\"a @ b\")),neg:c(function(a){return x(a,\"USub\")},d(\"-a\")),or_:c(function(a,b){return m(a,b,\"BitOr\")},d(\"a | b\")),pos:c(function(a){return x(a,\"UAdd\")},d(\"+a\")),pow:c(function(a,b){return m(a,b,\"Pow\")},d(\"a ** b\")),rshift:c(function(a,b){return m(a,b,\"RShift\")},d(\"a >> b\")),sub:c(function(a,b){return m(a,b,\"Sub\")},d(\"a - b\")),truediv:c(function(a,b){return m(a,b,\"Div\")},d(\"a / b\")),xor:c(function(a,b){return m(a,\nb,\"BitXor\")},d(\"a ^ b\")),concat:c(function(a,b){return T(a,b)},d(\"a + b, for a and b sequences\")),contains:c(function(a,b){return z(U(a,b),p)},d(\"b in a (note reversed operands)\")),countOf:c(function(a,b){return V(a,b)},\"Return thenumber of times b occurs in a.\"),delitem:c(function(a,b){return z(R(a,b,!0),function(){return H})},d(\"del a[b]\")),getitem:c(function(a,b){return C(a,b,!0)},d(\"a[b]\")),indexOf:c(function(a,b){return W(a,b)},\"Return the first index of b in a\"),setitem:c(function(a,b,e){return z(S(a,\nb,e,!0),function(){return H})},d(\"a[b] = c\")),length_hint:{$meth:function(a,b){if(void 0===b)b=new G(0);else if(!J(b))throw new v(\"'\"+L(b)+\"' object cannot be interpreted as an integer\");try{return Q(a)}catch(k){if(!(k instanceof v))throw k;}a=Y(a,t.$length_hint);if(void 0===a)return b;try{var e=aa(a,[])}catch(k){if(!(k instanceof v))throw k;return b}if(e===O)return b;if(!J(e))throw new v(\"__length_hint__ must be an integer, not \"+L(e));if(e.nb$isnegative())throw new N(\"__length_hint__() should return >= 0\");\nreturn e},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},iadd:c(function(a,b){return n(a,b,\"Add\")},d(\"a += b\")),iand:c(function(a,b){return n(a,b,\"BitAnd\")},d(\"a &= b\")),iconcat:c(function(a,\nb){return X(a,b)},d(\"a += b, for a and b sequences\")),ifloordiv:c(function(a,b){return n(a,b,\"FloorDiv\")},d(\"a //= b\")),ilshift:c(function(a,b){return n(a,b,\"LShift\")},d(\"a <<= b\")),imod:c(function(a,b){return n(a,b,\"Mod\")},d(\"a %= b\")),imul:c(function(a,b){return n(a,b,\"Mult\")},d(\"a *= b\")),imatmul:c(function(a,b){return n(a,b,\"MatMult\")},d(\"a @= b\")),ior:c(function(a,b){return n(a,b,\"BitOr\")},d(\"a |= b\")),ipow:c(function(a,b){return n(a,b,\"Pow\")},d(\"a **= b\")),irshift:c(function(a,b){return n(a,\nb,\"RShift\")},d(\"a >>= b\")),isub:c(function(a,b){return n(a,b,\"Sub\")},d(\"a -= b\")),itruediv:c(function(a,b){return n(a,b,\"Div\")},d(\"a /= b\")),ixor:c(function(a,b){return n(a,b,\"BitXor\")},d(\"a ^= b\"))});q.forEach(function(a){l[\"__\"+a.replace(\"_\",\"\")+\"__\"]=l[a]});l.div=l.truediv;l.__div__=l.div;return l};\n",
  "src/lib/random.js": "var MersenneTwister=function(e){void 0==e&&(e=(new Date).getTime());this.N=624;this.M=397;this.MATRIX_A=2567483615;this.UPPER_MASK=2147483648;this.LOWER_MASK=2147483647;this.mt=Array(this.N);this.mti=this.N+1;this.init_genrand(e)};MersenneTwister.prototype.init_genrand=function(e){this.mt[0]=e>>>0;for(this.mti=1;this.mti<this.N;this.mti++)e=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(1812433253*((e&4294901760)>>>16)<<16)+1812433253*(e&65535)+this.mti,this.mt[this.mti]>>>=0};\nMersenneTwister.prototype.init_by_array=function(e,d){var f;this.init_genrand(19650218);var h=1;var l=0;for(f=this.N>d?this.N:d;f;f--){var a=this.mt[h-1]^this.mt[h-1]>>>30;this.mt[h]=(this.mt[h]^(1664525*((a&4294901760)>>>16)<<16)+1664525*(a&65535))+e[l]+l;this.mt[h]>>>=0;h++;l++;h>=this.N&&(this.mt[0]=this.mt[this.N-1],h=1);l>=d&&(l=0)}for(f=this.N-1;f;f--)a=this.mt[h-1]^this.mt[h-1]>>>30,this.mt[h]=(this.mt[h]^(1566083941*((a&4294901760)>>>16)<<16)+1566083941*(a&65535))-h,this.mt[h]>>>=0,h++,h>=\nthis.N&&(this.mt[0]=this.mt[this.N-1],h=1);this.mt[0]=2147483648};\nMersenneTwister.prototype.genrand_int32=function(){var e=[0,this.MATRIX_A];if(this.mti>=this.N){var d;this.mti==this.N+1&&this.init_genrand(5489);for(d=0;d<this.N-this.M;d++){var f=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK;this.mt[d]=this.mt[d+this.M]^f>>>1^e[f&1]}for(;d<this.N-1;d++)f=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+(this.M-this.N)]^f>>>1^e[f&1];f=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK;this.mt[this.N-1]=this.mt[this.M-\n1]^f>>>1^e[f&1];this.mti=0}f=this.mt[this.mti++];f^=f>>>11;f^=f<<7&2636928640;f^=f<<15&4022730752;return(f^f>>>18)>>>0};MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1};MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)};MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)};MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)};\nMersenneTwister.prototype.genrand_res53=function(){var e=this.genrand_int32()>>>5,d=this.genrand_int32()>>>6;return 1.1102230246251565E-16*(67108864*e+d)};\nvar $builtinmodule=function(e){e={};var d=new MersenneTwister,f=void 0;e.seed=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1);a=Sk.builtin.asnum$(a);d=0<arguments.length?new MersenneTwister(a):new MersenneTwister;return Sk.builtin.none.none$});e.random=new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0);return new Sk.builtin.float_(d.genrand_res53())});var h=function(a,b,c){if(!Sk.builtin.checkInt(a))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\nif(void 0===b)return a=d.genrand_res53()*a|0,new Sk.builtin.int_(a);if(!Sk.builtin.checkInt(b))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");void 0===c&&(c=1);var g=b-a;if(1==c&&0<g)return a+=d.genrand_res53()*g|0,new Sk.builtin.int_(a);if(1==c)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+a+\", \"+b+\", \"+g+\")\");if(!Sk.builtin.checkInt(c))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(0<c)b=(g+c-1)/c|0;else if(0>c)b=(g+c+1)/c|0;else throw new Sk.builtin.ValueError(\"zero step for randrange()\");\nif(0>=b)throw new Sk.builtin.ValueError(\"empty range for randrange()\");a+=c*(d.genrand_res53()*b|0);return new Sk.builtin.int_(a)};e.randint=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return h(a,b+1)});e.randrange=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);c=Sk.builtin.asnum$(c);return h(a,b,c)});e.uniform=\nnew Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2);a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);var c=d.genrand_res53();return new Sk.builtin.float_(a+c*(b-a))});e.triangular=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3);Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);if(a>b){var g=\na;a=b;b=g}void 0===c||c===Sk.builtin.none.none$?c=(b-a)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(c)),c=Sk.builtin.asnum$(c));g=d.genrand_res53();return new Sk.builtin.float_(g<(c-a)/(b-a)?a+Math.sqrt(g*(b-a)*(c-a)):b-Math.sqrt((1-g)*(b-a)*(b-c)))});var l=function(a,b){if(void 0!==f){var c=f;f=void 0}else{var g=d.genrand_res53();var k=d.genrand_res53();g=Math.sqrt(-2*Math.log(g));k*=2*Math.PI;c=g*Math.cos(k);f=g*Math.sin(k)}return a+b*c};e.gauss=new Sk.builtin.func(function(a,\nb){Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(l(a,b))});e.normalvariate=e.gauss;e.lognormvariate=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\n\"number\",Sk.builtin.checkNumber(b));a=Sk.builtin.asnum$(a);b=Sk.builtin.asnum$(b);return new Sk.builtin.float_(Math.exp(l(a,b)))});e.expovariate=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1);Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);var b=d.genrand_res53();return new Sk.builtin.float_(-Math.log(b)/a)});e.choice=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1);Sk.builtin.pyCheckType(\"seq\",\n\"sequence\",Sk.builtin.checkSequence(a));if(void 0!==a.sq$length){var b=new Sk.builtin.int_(d.genrand_res53()*a.sq$length()|0);return a.mp$subscript(b)}throw new Sk.builtin.TypeError(\"object has no length\");});e.shuffle=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1);Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(a));if(a.constructor===Sk.builtin.list)for(var b=a.v,c=b.length-1;0<c;--c){var g=d.genrand_res53()*(c+1)|0,k=b[g];b[g]=b[c];b[c]=\nk}else if(void 0!==a.sq$length)if(void 0!==a.mp$ass_subscript)for(c=a.sq$length()-1;0<c;--c)g=new Sk.builtin.int_(d.genrand_res53()*(c+1)|0),c=new Sk.builtin.int_(c),k=a.mp$subscript(g),a.mp$ass_subscript(g,a.mp$subscript(c)),a.mp$ass_subscript(c,k);else throw new Sk.builtin.TypeError(\"object is immutable\");else throw new Sk.builtin.TypeError(\"object has no length\");return Sk.builtin.none.none$});e.sample=new Sk.builtin.func(function(a,b){var c;Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,\n2,2);Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(a));Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(b));b=Sk.builtin.asnum$(b);var g=[];var k=Sk.abstr.iter(a);var m=0;for(c=k.tp$iternext();void 0!==c;m++,c=k.tp$iternext()){var n=Math.floor(d.genrand_res53()*(m+1));m<b?(n<m&&(g[m]=g[n]),g[n]=c):n<b&&(g[n]=c)}if(m<b)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(g)});return e};\n",
  "src/lib/re.js": "var $builtinmodule=function(x){var g={__name__:new Sk.builtin.str(\"re\")};g.I=2;g.IGNORECASE=2;g.M=8;g.MULTILINE=8;var v=[\"(?:\",\"(?=\",\"(?!\"];var t=function(b){var c,d;if(c=b.match(/\\(\\?./g))for(d=0;d<c.length;d++)if(-1==v.indexOf(c[d]))throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"+c[d]+\"'\");b.replace(\"/\\\\/g\",\"\\\\\\\\\");return b.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\")};var u=function(b){var c=\"g\";(b&g.IGNORECASE)==g.IGNORECASE&&(c+=\"i\");(b&g.MULTILINE)==g.MULTILINE&&(c+=\"m\");return c};\nvar n=function(b,c,d,a){var e,f,k;Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,4);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===d&&(d=0);if(!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"maxsplit must be a number\");void 0===a&&(a=0);if(!Sk.builtin.checkNumber(a))throw new Sk.builtin.TypeError(\"flags must be a number\");d=Sk.builtin.asnum$(d);\nvar h=Sk.ffi.remapToJs(b);var l=Sk.ffi.remapToJs(c);h=t(h);var w=null!==h.match(/^\\(.*\\)$/);var m=u(a);h=new RegExp(h,m);m=[];e;for(k=f=0;null!=(e=h.exec(l))&&e.index!==h.lastIndex&&!(m.push(new Sk.builtin.str(l.substring(f,e.index))),w&&m.push(new Sk.builtin.str(e[0])),f=h.lastIndex,k+=1,d&&k>=d););m.push(new Sk.builtin.str(l.substring(f)));return new Sk.builtin.list(m)};n.co_varnames=[\"pattern\",\"string\",\"maxsplit\",\"flags\"];n.$defaults=[new Sk.builtin.int_(0),new Sk.builtin.int_(0)];g.split=new Sk.builtin.func(n);\nvar p=function(b,c,d){var a;Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,3);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===d&&(d=0);if(!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");var e=Sk.ffi.remapToJs(b);var f=Sk.ffi.remapToJs(c);e=t(e);var k=u(d);k=new RegExp(e,k);e.match(/\\$/)&&f.match(new RegExp(/\\n$/))&&(f=\nf.slice(0,-1));e=[];for(a;null!=(a=k.exec(f));){if(2>a.length)e.push(new Sk.builtin.str(a[0]));else if(2==a.length)e.push(new Sk.builtin.str(a[1]));else{for(var h=[],l=1;l<a.length;l++)h.push(new Sk.builtin.str(a[l]));e.push(new Sk.builtin.tuple(h))}a.index===k.lastIndex&&(k.lastIndex+=1)}return new Sk.builtin.list(e)};p.co_varnames=[\"pattern\",\"string\",\"flags\"];p.$defaults=[new Sk.builtin.int_(0)];g.findall=new Sk.builtin.func(p);g.MatchObject=Sk.misceval.buildClass(g,function(b,c){c.__init__=new Sk.builtin.func(function(d,\na,e,f){d.thematch=a;d.re=e;d.string=f;return Sk.builtin.none.none$});c.groups=new Sk.builtin.func(function(d){d=d.thematch.v.slice(1);return new Sk.builtin.tuple(d)});c.group=new Sk.builtin.func(function(d,a){a=void 0===a?0:Sk.builtin.asnum$(a);if(a>=d.thematch.v.length)throw new Sk.builtin.IndexError(\"Index out of range: \"+a);return d.thematch.v[a]})},\"MatchObject\",[]);g._findre=function(b,c){b=b.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\");b=eval(b);c=Sk.ffi.remapToJs(c);c=c.match(/\\n$/)?c.slice(0,\n-1).match(b):c.match(b);var d=new Sk.builtin.list;if(null==c)return d;for(var a=0;a<c.length;++a)b=new Sk.builtin.str(c[a]),d.v.push(b);return d};var q=function(b,c,d){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,3);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===d&&(d=0);if(!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");\nvar a=\"/\"+b.v.replace(/\\//g,\"\\\\/\")+\"/\";a=g._findre(a,c);return 1>a.v.length?Sk.builtin.none.none$:Sk.misceval.callsimArray(g.MatchObject,[a,b,c])};q.co_varnames=[\"pattern\",\"string\",\"flags\"];q.$defaults=[new Sk.builtin.int_(0)];g.search=new Sk.builtin.func(q);var r=function(b,c,d){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,3);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"string must be a string\");\nvoid 0===d&&(d=0);if(!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");var a=\"/^\"+Sk.ffi.remapToJs(b).replace(/\\//g,\"\\\\/\")+\"/\";a=g._findre(a,c);return 1>Sk.ffi.remapToJs(a).length?Sk.builtin.none.none$:Sk.misceval.callsimArray(g.MatchObject,[a,b,c])};r.co_varnames=[\"pattern\",\"string\",\"flags\"];r.$defaults=[new Sk.builtin.int_(0)];g.match=new Sk.builtin.func(r);g.RegexObject=Sk.misceval.buildClass(g,function(b,c){c.__init__=new Sk.builtin.func(function(a,e,f){a.re=\ne;a.flags=void 0===f?0:f;return Sk.builtin.none.none$});b=new Sk.builtin.func(function(a){a=\"re.compile('\"+Sk.ffi.remapToJs(a.re)+\"')\";return Sk.ffi.remapToPy(a.substring(0,212))});c.__str__=b;c.__repr__=b;var d=function(a,e,f){a=Sk.ffi.remapToJs(a);e=void 0==e?0:Sk.ffi.remapToJs(e);f=void 0==f?a.length:Sk.ffi.remapToJs(f);\"^\"==e&&(e=a.indexOf(\"\\n\")+1);null===f&&(f=a.length);return Sk.ffi.remapToPy(a.substring(e,f))};b=function(a,e,f,k){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,4);var h=\nd(e,f,k);return q(a.re,h,a.flags)};b.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];b.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];c.search=new Sk.builtin.func(b);b=function(a,e,f,k){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,4);var h=d(e,f,k);return r(a.re,h,a.flags)};b.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];b.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];c.match=new Sk.builtin.func(b);b=function(a,e,f){Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,3);\nvoid 0===f&&(f=0);if(!Sk.builtin.checkInt(f))throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");return n(a.re,e,f,a.flags)};b.co_varnames=[\"self\",\"string\",\"maxsplit\"];b.$defaults=[new Sk.builtin.int_(0)];c.split=new Sk.builtin.func(b);b=function(a,e,f,k){Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,4);var h=d(e,f,k);return p(a.re,h,a.flags)};b.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];b.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];c.findall=new Sk.builtin.func(b)},\n\"RegexObject\",[]);g.compile=new Sk.builtin.func(function(b,c){Sk.builtin.pyCheckArgsLen(\"compile\",arguments.length,1,2);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"pattern must be a string\");void 0===c&&(c=0);if(!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");return Sk.misceval.callsimArray(g.RegexObject,[b,c])});g.purge=new Sk.builtin.func(function(){});return g};\n",
  "src/lib/string.js": "var $builtinmodule=function(h){var a={};a.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.ascii_letters=new Sk.builtin.str(a.ascii_lowercase.v+a.ascii_uppercase.v);a.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.letters=new Sk.builtin.str(a.lowercase.v+a.uppercase.v);a.digits=new Sk.builtin.str(\"0123456789\");a.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\");\na.octdigits=new Sk.builtin.str(\"01234567\");a.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\");a.whitespace=new Sk.builtin.str(\"\\t\\n\\x0B\\f\\r \");a.printable=new Sk.builtin.str(a.digits.v+a.letters.v+a.punctuation.v+\" \\t\\n\\r\\x0B\\f\");a.split=new Sk.builtin.func(function(c){for(var b=[],d=0;d<arguments.length;++d)b[d-0]=arguments[d];return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,b)});a.capitalize=new Sk.builtin.func(function(c){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,\n[c])});a.join=new Sk.builtin.func(function(c,b){void 0===b&&(b=new Sk.builtin.str(\" \"));return Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[b,c])});a.capwords=new Sk.builtin.func(function(c,b){Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2);if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"s must be a string\");void 0===b&&(b=new Sk.builtin.str(\" \"));if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var d=Sk.misceval.callsimArray(a.split,\n[c,b]).v,f=[],e=0;e<d.length;e++){var g=Sk.misceval.callsimArray(a.capitalize,[d[e]]);f.push(g)}return Sk.misceval.callsimArray(a.join,[new Sk.builtin.list(f),b])});return a};\n"
}