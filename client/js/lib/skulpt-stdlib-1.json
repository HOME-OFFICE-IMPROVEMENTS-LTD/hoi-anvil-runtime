{
  "src/lib/collections.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(f){var g=0;return function(){return g<f.length?{done:!1,value:f[g++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.makeIterator=function(f){var g=\"undefined\"!=typeof Symbol&&Symbol.iterator&&f[Symbol.iterator];return g?g.call(f):$jscomp.arrayIterator(f)};$jscomp.arrayFromIterator=function(f){for(var g,k=[];!(g=f.next()).done;)k.push(g.value);return k};\n$jscomp.arrayFromIterable=function(f){return f instanceof Array?f:$jscomp.arrayFromIterator($jscomp.makeIterator(f))};function $builtinmodule(f){var g={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),function(f){g._iskeyword=f.$d.iskeyword;return Sk.importModule(\"itertools\",!1,!0)},function(f){g._chain=f.$d.chain;g._starmap=f.$d.starmap;g._repeat=f.$d.repeat;return Sk.importModule(\"operator\",!1,!0)},function(f){g._itemgetter=f.$d.itemgetter},function(){return collections_mod(g)})}\nfunction collections_mod(f){function g(a){return function(b){if(void 0!==b&&!(b instanceof f.Counter))return Sk.builtin.NotImplemented.NotImplemented$;var c=new f.Counter;a.call(this,c,b);return c}}function k(a,b){return function(c){if(!(c instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+a+\"= \"+Sk.abstr.typeName(c)+\" is not supported\");b.call(this,c);return this.keep$positive()}}function n(a,b,c,d,e){function r(a,b){return a.prototype.tp$new(Sk.misceval.arrayFromIterable(b))}\nfunction l(a){for(var b=[],c=0;c<a._fields.v.length;c++)b.push(a._fields.v[c]),b.push(a.v[c]);return new Sk.builtin.dict(b)}function g(a,b){a=new Sk.builtin.dict(a);var c=a.tp$getattr(new Sk.builtin.str(\"pop\")),d=Sk.abstr.gattr(b,new Sk.builtin.str(\"_make\")),e=Sk.misceval.callsimArray;b=e(d,[e(Sk.builtin.map_,[c,n,b])]);if(a.sq$length())throw a=a.sk$asarray(),new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+a.map(function(a){return\"'\"+a.$jsstr()+\"'\"})+\"]\");return b}a=a.tp$str();if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,\n[a])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(a)+\"'\");a=a.$jsstr();if(u.test(a)||!q.test(a)||!a)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+a+\"'\");if(Sk.builtin.checkString(b)){var h=b.$jsstr().replace(v,\" \").split(w);1==h.length&&\"\"===h[0]&&(h=[]);var m=h.map(function(a){return new Sk.builtin.str(a)})}else{h=[];m=[];b=Sk.abstr.iter(b);for(var k=b.tp$iternext();void 0!==k;k=b.tp$iternext())k=\nk.tp$str(),m.push(k),h.push(k.$jsstr())}b=new Set;if(Sk.misceval.isTrue(c))for(c=0;c<h.length;c++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,[m[c]]))||t.test(h[c])||!q.test(h[c])||!h[c]||b.has(h[c]))h[c]=\"_\"+c,m[c]=new Sk.builtin.str(\"_\"+c);b.add(h[c])}else for(c=0;c<h.length;c++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(f._iskeyword,[m[c]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+h[c]+\"'\");if(t.test(h[c]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+\nh[c]+\"'\");if(!q.test(h[c])||!h[c])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+h[c]+\"'\");if(b.has(h[c]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+h[c]+\"'\");b.add(h[c])}var n=new Sk.builtin.tuple(m);c=[];var p=[];if(!Sk.builtin.checkNone(d)){p=Sk.misceval.arrayFromIterable(d);if(p.length>h.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");d=0;for(b=m.length-p.length;b<m.length;d++,b++)c.push(m[b]),\nc.push(p[d])}d=new Sk.builtin.dict(c);r.co_varnames=[\"_cls\",\"iterable\"];l.co_varnames=[\"self\"];g.co_kwargs=1;g.co_varnames=[\"_self\"];c={};for(b=0;b<h.length;b++)c[m[b].$mangled]=new Sk.builtin.property(new f._itemgetter([new Sk.builtin.int_(b)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+b));return Sk.abstr.buildNativeClass(a,{constructor:function(){},base:Sk.builtin.tuple,slots:{tp$doc:a+\"(\"+h.join(\", \")+\")\",tp$new:function(a,b){a=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",h,a,b,\np);b=new this.constructor;Sk.builtin.tuple.call(b,a);return b},$r:function(){var a=this.v.map(function(a,b){return h[b]+\"=\"+Sk.misceval.objectRepr(a)});return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a.join(\", \")+\")\")}},proto:Object.assign({__module__:Sk.builtin.checkNone(e)?Sk.globals.__name__:e,__slots__:new Sk.builtin.tuple,_fields:n,_field_defaults:d,_make:new Sk.builtin.classmethod(new Sk.builtin.func(r)),_asdict:new Sk.builtin.func(l),_replace:new Sk.builtin.func(g)},c)})}f.__all__=new Sk.builtin.list([\"deque\",\n\"defaultdict\",\"namedtuple\",\"Counter\",\"OrderedDict\"].map(function(a){return new Sk.builtin.str(a)}));f.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function(a,b){this.default_factory=a;Sk.builtin.dict.call(this,b)},base:Sk.builtin.dict,methods:{copy:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth:function(a){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(a));\nvar b=Sk.misceval.callsimArray(this.default_factory,[]);this.mp$ass_subscript(a,b);return b},$flags:{OneArg:!0}}},getsets:{default_factory:{$get:function(){return this.default_factory},$set:function(a){this.default_factory=a=a||Sk.builtin.none.none$}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --\\x3e dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",\ntp$init:function(a,b){var c=a.shift();if(void 0===c)this.default_factory=Sk.builtin.none.none$;else if(Sk.builtin.checkCallable(c)||Sk.builtin.checkNone(c))this.default_factory=c;else throw new Sk.builtin.TypeError(\"first argument must be callable\");return Sk.builtin.dict.prototype.tp$init.call(this,a,b)},$r:function(){var a=Sk.misceval.objectRepr(this.default_factory),b=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+a+\", \"+b+\")\")}},proto:{$copy:function(){var a=\nthis,b=[];Sk.misceval.iterFor(Sk.abstr.iter(this),function(c){b.push(c);b.push(a.mp$subscript(c))});return new f.defaultdict(this.default_factory,b)}}});f.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function(){this.$d=new Sk.builtin.dict;Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth:function(){var a=f._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),b=Sk.misceval.callsimArray;return b(a,[b(f._starmap,[f._repeat,b(this.tp$getattr(this.str$items))])])}},\nmost_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},$meth:function(a){var b=this.sq$length();Sk.builtin.checkNone(a)?a=b:(a=Sk.misceval.asIndexOrThrow(a),a=a>b?b:0>a?0:a);b=this.$items().sort(function(a,b){return Sk.misceval.richCompareBool(a[1],b[1],\"Lt\")?1:Sk.misceval.richCompareBool(a[1],b[1],\"Gt\")?-1:0});return new Sk.builtin.list(b.slice(0,a).map(function(a){return new Sk.builtin.tuple(a)}))}},update:{$flags:{FastCall:!0},$meth:function(a,b){Sk.abstr.checkArgsLen(\"update\",\na,0,1);return this.counter$update(a,b)}},subtract:{$flags:{FastCall:!0},$meth:function(a,b){Sk.abstr.checkArgsLen(\"subtract\",a,0,1);a=a[0];if(void 0!==a)if(a instanceof Sk.builtin.dict)for(var c=Sk.abstr.iter(a),d=c.tp$iternext();void 0!==d;d=c.tp$iternext()){var e=this.mp$subscript(d);this.mp$ass_subscript(d,Sk.abstr.numberBinOp(e,a.mp$subscript(d),\"Sub\"))}else for(a=Sk.abstr.iter(a),c=a.tp$iternext();void 0!==c;c=a.tp$iternext())d=this.mp$subscript(c),this.mp$ass_subscript(c,Sk.abstr.numberBinOp(d,\nthis.$one,\"Sub\"));b=b||[];for(a=0;a<b.length;a+=2)c=new Sk.builtin.str(b[a]),d=this.mp$subscript(c),this.mp$ass_subscript(c,Sk.abstr.numberBinOp(d,b[a+1],\"Sub\"));return Sk.builtin.none.none$}},__missing__:{$meth:function(a){return this.$zero},$flags:{OneArg:!0}},copy:{$meth:function(){return Sk.misceval.callsimArray(f.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",\ntp$init:function(a,b){Sk.abstr.checkArgsLen(this.tpjs_name,a,0,1);return this.counter$update(a,b)},$r:function(){var a=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript:function(a,b){return void 0===b?this.mp$lookup(a)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b)},tp$as_number:!0,nb$positive:g(function(a){var b=this;\nthis.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;Sk.misceval.richCompareBool(d,b.$zero,\"Gt\")&&a.mp$ass_subscript(c,d)})}),nb$negative:g(function(a){var b=this;this.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;Sk.misceval.richCompareBool(d,b.$zero,\"Lt\")&&a.mp$ass_subscript(c,Sk.abstr.numberBinOp(b.$zero,d,\"Sub\"))})}),nb$subtract:g(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);\nd=e.next().value;e=e.next().value;e=Sk.abstr.numberBinOp(e,b.mp$subscript(d),\"Sub\");Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(b){var d=$jscomp.makeIterator(b);b=d.next().value;d=d.next().value;void 0===c.mp$lookup(b)&&Sk.misceval.richCompareBool(d,c.$zero,\"Lt\")&&a.mp$ass_subscript(b,Sk.abstr.numberBinOp(c.$zero,d,\"Sub\"))})}),nb$add:g(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=\ne.next().value;e=Sk.abstr.numberBinOp(e,b.mp$subscript(d),\"Add\");Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(b){var d=$jscomp.makeIterator(b);b=d.next().value;d=d.next().value;void 0===c.mp$lookup(b)&&Sk.misceval.richCompareBool(d,c.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)})}),nb$inplace_add:k(\"+\",function(a){var b=this;a.$items().forEach(function(a){var c=$jscomp.makeIterator(a);a=c.next().value;c=c.next().value;c=Sk.abstr.numberInplaceBinOp(b.mp$subscript(a),\nc,\"Add\");b.mp$ass_subscript(a,c)})}),nb$inplace_subtract:k(\"-\",function(a){var b=this;a.$items().forEach(function(a){var c=$jscomp.makeIterator(a);a=c.next().value;c=c.next().value;c=Sk.abstr.numberInplaceBinOp(b.mp$subscript(a),c,\"Sub\");b.mp$ass_subscript(a,c)})}),nb$or:g(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;var f=b.mp$subscript(d);e=Sk.misceval.richCompareBool(e,f,\"Lt\")?f:e;Sk.misceval.richCompareBool(e,c.$zero,\n\"Gt\")&&a.mp$ass_subscript(d,e)});b.$items().forEach(function(b){var d=$jscomp.makeIterator(b);b=d.next().value;d=d.next().value;void 0===c.mp$lookup(b)&&Sk.misceval.richCompareBool(d,c.$zero,\"Gt\")&&a.mp$ass_subscript(b,d)})}),nb$and:g(function(a,b){var c=this;this.$items().forEach(function(d){var e=$jscomp.makeIterator(d);d=e.next().value;e=e.next().value;var f=b.mp$subscript(d);e=Sk.misceval.richCompareBool(e,f,\"Lt\")?e:f;Sk.misceval.richCompareBool(e,c.$zero,\"Gt\")&&a.mp$ass_subscript(d,e)})}),nb$inplace_and:k(\"&\",\nfunction(a){var b=this;this.$items().forEach(function(c){var d=$jscomp.makeIterator(c);c=d.next().value;d=d.next().value;var e=a.mp$subscript(c);Sk.misceval.richCompareBool(e,d,\"Lt\")&&b.mp$ass_subscript(c,e)})}),nb$inplace_or:k(\"|\",function(a){var b=this;a.$items().forEach(function(a){var c=$jscomp.makeIterator(a);a=c.next().value;c=c.next().value;Sk.misceval.richCompareBool(c,b.mp$subscript(a),\"Gt\")&&b.mp$ass_subscript(a,c)})}),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},\nproto:{keep$positive:function(){var a=this;this.$items().forEach(function(b){var c=$jscomp.makeIterator(b);b=c.next().value;c=c.next().value;Sk.misceval.richCompareBool(c,a.$zero,\"LtE\")&&a.mp$ass_subscript(b)});return this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update:function(a,b){var c=a[0];if(void 0!==c)if(Sk.builtin.checkMapping(c))if(this.sq$length()){a=Sk.abstr.iter(c);for(var d=a.tp$iternext();void 0!==d;d=a.tp$iternext()){var e=\nthis.mp$subscript(d);this.mp$ass_subscript(d,Sk.abstr.numberBinOp(e,c.mp$subscript(d),\"Add\"))}}else this.update$common(a,void 0,\"update\");else for(c=Sk.abstr.iter(c),a=c.tp$iternext();void 0!==a;a=c.tp$iternext())d=this.mp$subscript(a),this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,this.$one,\"Add\"));if(b&&b.length)if(this.sq$length())for(c=0;c<b.length;c+=2)a=new Sk.builtin.str(b[c]),d=this.mp$subscript(a),this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,b[c+1],\"Add\"));else this.update$common([],b,\n\"update\");return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\");},$flags:{MinArgs:1,MaxArgs:2}}}});f.OrderedDict=Sk.abstr.buildNativeClass(\"collections.OrderedDict\",{constructor:function(){Sk.builtin.dict.call(this)},base:Sk.builtin.dict,slots:{tp$doc:\"Dictionary that remembers insertion order\",$r:function(){if(this.in$repr)return new Sk.builtin.str(Sk.abstr.typeName(this)+\n\"(...)\");this.in$repr=!0;var a=this.$items().map(function(a){var b=$jscomp.makeIterator(a);a=b.next().value;b=b.next().value;return\"(\"+Sk.misceval.objectRepr(a)+\", \"+Sk.misceval.objectRepr(b)+\")\"});a=0===a.length?\"\":\"[\"+a.join(\", \")+\"]\";this.in$repr=!1;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$richcompare:function(a,b){if(\"Eq\"!==b&&\"Ne\"!==b)return Sk.builtin.NotImplemented.NotImplemented$;if(!(a instanceof f.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,\na,b);b=\"Eq\"==b?!0:!1;var c=this.size;if(c!==a.size)return!b;a=a.$items();for(var d=this.$items(),e=0;e<c;e++){var g=d[e],l=a[e],k=g[0],h=l[0];if(k!==h&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(k,h,\"Eq\")))return!b;g=g[1];l=l[1];if(g!==l&&!Sk.misceval.isTrue(Sk.misceval.richCompareBool(g,l,\"Eq\")))return!b}return b}},methods:{move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth:function(a,b){var c;for(c in this.entries){var d=this.entries[c][0];if(d===a||Sk.misceval.richCompareBool(d,\na,\"Eq\")){var e=c;break}}if(void 0===e)throw new Sk.builtin.KeyError(a);a=this.entries[e];delete this.entries[e];Sk.misceval.isTrue(b)?this.entries[e]=a:(b={},this.entries=Object.assign({},(b[e]=a,b),this.entries));return Sk.builtin.none.none$}}}});f.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function(a,b,c,d,e){this.head=c||0;this.tail=d||0;this.mask=e||1;this.maxlen=b;this.v=a||Array(2)},slots:{tp$doc:\"deque([iterable[, maxlen]]) --\\x3e deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",\ntp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],a,b));a=b.next().value;b=b.next().value;if(void 0!==b&&!Sk.builtin.checkNone(b)){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError,\"an integer is required\");if(0>b)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");this.maxlen=b}this.$clear();void 0!==a&&this.$extend(a)},tp$getattr:Sk.generic.getAttr,tp$richcompare:function(a,\nb){if(this===a&&Sk.misceval.opAllowsEquality(b))return!0;if(!(a instanceof f.deque))return Sk.builtin.NotImplemented.NotImplemented$;var c=a,d=this.v;a=a.v;var e=this.tail-this.head&this.mask,g=c.tail-c.head&c.mask,l=Math.max(e,g);if(e===g)for(l=0;l<e&&l<g;++l){var k=Sk.misceval.richCompareBool(d[this.head+l&this.mask],a[c.head+l&c.mask],\"Eq\");if(!k)break}if(l>=e||l>=g)switch(b){case \"Lt\":return e<g;case \"LtE\":return e<=g;case \"Eq\":return e===g;case \"NotEq\":return e!==g;case \"Gt\":return e>g;case \"GtE\":return e>=\ng}return\"Eq\"===b?!1:\"NotEq\"===b?!0:Sk.misceval.richCompareBool(d[this.head+l&this.mask],a[c.head+l&c.mask],b)},tp$iter:function(){return new x(this)},$r:function(){var a=[],b=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(var c=0;c<b;c++)a.push(Sk.misceval.objectRepr(this.v[this.head+c&this.mask]));b=Sk.abstr.typeName(this);if(void 0!==this.maxlen)return new Sk.builtin.str(b+\"([\"+a.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\n\")\");this.$entered_repr=void 0;return new Sk.builtin.str(b+\"([\"+a.filter(Boolean).join(\", \")+\"])\")},tp$as_number:!0,nb$bool:function(){return 0!==(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains:function(a){for(var b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(Sk.misceval.richCompareBool(c,a,\"Eq\"))return!0;return!1},sq$concat:function(a){if(!(a instanceof f.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+Sk.abstr.typeName(a)+\n\"') to deque\");var b=this.$copy();a=a.tp$iter();for(var c=a.tp$iternext();void 0!==c;c=a.tp$iternext())b.$push(c);return b},sq$length:function(){return this.tail-this.head&this.mask},sq$repeat:function(a){a=Sk.misceval.asIndexOrThrow(a,\"can't multiply sequence by non-int of type '{tp$name}'\");var b=this.tail-this.head&this.mask,c=this.$copy();0>=a&&c.$clear();for(var d=1;d<a;d++)for(var e=0;e<b;e++){var f=this.head+e&this.mask;c.$push(this.v[f])}return c},mp$subscript:function(a){a=Sk.misceval.asIndexOrThrow(a);\nvar b=this.tail-this.head&this.mask;if(a>=b||a<-b)throw new Sk.builtin.IndexError(\"deque index out of range\");return this.v[(0<=a?this.head:this.tail)+a&this.mask]},mp$ass_subscript:function(a,b){a=Sk.misceval.asIndexOrThrow(a);var c=this.tail-this.head&this.mask;if(a>=c||a<-c)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===b?this.del$item(a):this.set$item(a,b)},nb$inplace_add:function(a){this.maxlen=void 0;a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$push(b);\nreturn this},nb$inplace_multiply:function(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\");0>=a&&this.$clear();for(var b=this.$copy(),c=this.tail-this.head&this.mask,d=1;d<a;d++)for(var e=0;e<c;e++)b.$push(this.v[this.head+e&this.mask]);this.v=b.v;this.head=b.head;this.tail=b.tail;this.mask=b.mask;return this}},methods:{append:{$meth:function(a){this.$push(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},\nappendleft:{$meth:function(a){this.$pushLeft(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},clear:{$meth:function(){this.$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth:function(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,\n$doc:\"Return a shallow copy of a deque.\"},count:{$meth:function(a){for(var b=this.tail-this.head&this.mask,c=0,d=0;d<b;d++)Sk.misceval.richCompareBool(this.v[this.head+d&this.mask],a,\"Eq\")&&c++;return new Sk.builtin.int_(c)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth:function(a){this.$extend(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},\nextendleft:{$meth:function(a){a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$pushLeft(b);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth:function(a,b,c){b=this.$index(a,b,c);if(void 0!==b)return new Sk.builtin.int_(b);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},\ninsert:{$meth:function(a,b){a=Sk.misceval.asIndexOrThrow(a,\"integer argument expected, got {tp$name}\");var c=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&c>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");a>c&&(a=c);a<=-c&&(a=0);a=(0<=a?this.head:this.tail)+a&this.mask;c=this.tail;for(this.tail=this.tail+1&this.mask;c!==a;){var d=c-1&this.mask;this.v[c]=this.v[d];c=d}this.v[a]=b;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);return Sk.builtin.none.none$},\n$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},pop:{$meth:function(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth:function(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth:function(a){var b=this.$index(a);if(void 0===b)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");for(a=\nthis.head+b&this.mask;a!==this.tail;)b=a+1&this.mask,this.v[a]=this.v[b],a=b;this.tail=this.tail-1&this.mask;a=this.tail-this.head&this.mask;a<this.mask>>>1&&this.$resize(a,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth:function(){return new y(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth:function(){for(var a=this.head,b=this.tail,c=this.mask,\nd=this.tail-this.head&this.mask,e=0;e<~~(d/2);e++){var f=b-e-1&c,g=a+e&c,k=this.v[f];this.v[f]=this.v[g];this.v[g]=k}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth:function(a){a=void 0===a?1:Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);var b=this.head,c=this.tail;if(0===a||b===c)return this;this.head=b-a&this.mask;this.tail=c-a&this.mask;if(0<a)for(var d=1;d<=a;d++){var e=c-d&this.mask;this.v[b-d&this.mask]=this.v[e];\nthis.v[e]=void 0}else for(d=0;d>a;d--)e=b-d&this.mask,this.v[c-d&this.mask]=this.v[e],this.v[e]=void 0;return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},getsets:{maxlen:{$get:function(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear:function(){this.tail=this.head=0;this.mask=1;\nthis.v=Array(2)},$copy:function(){return new f.deque(this.v.slice(0),this.maxlen,this.head,this.tail,this.mask)},$extend:function(a){a=Sk.abstr.iter(a);for(var b=a.tp$iternext();void 0!==b;b=a.tp$iternext())this.$push(b)},set$item:function(a,b){this.v[(0<=a?this.head:this.tail)+a&this.mask]=b},del$item:function(a){for(a=(0<=a?this.head:this.tail)+a&this.mask;a!==this.tail;){var b=a+1&this.mask;this.v[a]=this.v[b];a=b}a=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask;a<this.mask>>>1&&\nthis.$resize(a,this.v.length>>>1)},$push:function(a){this.v[this.tail]=a;this.tail=this.tail+1&this.mask;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$popLeft();return this},$pushLeft:function(a){this.head=this.head-1&this.mask;this.v[this.head]=a;this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);a=this.tail-this.head&this.mask;void 0!==this.maxlen&&a>this.maxlen&&this.$pop();return this},\n$pop:function(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");this.tail=this.tail-1&this.mask;var a=this.v[this.tail];this.v[this.tail]=void 0;var b=this.tail-this.head&this.mask;b<this.mask>>>1&&this.$resize(b,this.v.length>>>1);return a},$popLeft:function(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");var a=this.v[this.head];this.v[this.head]=void 0;this.head=this.head+1&this.mask;var b=this.tail-this.head&this.mask;b<\nthis.mask>>>1&&this.$resize(b,this.v.length>>>1);return a},$resize:function(a,b){var c=this.head,d=this.mask;this.head=0;this.tail=a;this.mask=b-1;if(0===c)this.v.length=b;else{b=Array(b);for(var e=0;e<a;e++)b[e]=this.v[c+e&d];this.v=b}},$index:function(a,b,c){var d=this.tail-this.head&this.mask;b=void 0===b?0:Sk.misceval.asIndexOrThrow(b);c=void 0===c?d:Sk.misceval.asIndexOrThrow(c);var e=this.head,f=this.mask,g=this.v;c=0<=c?c:c<-d?0:d+c;for(b=0<=b?b:b<-d?0:d+b;b<c;b++)if(g[e+b&f]===a)return b},\nsk$asarray:function(){for(var a=[],b=this.tail-this.head&this.mask,c=0;c<b;++c)a.push(this.v[this.head+c&this.mask]);return a}}});var x=Sk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function(a){this.$index=0;this.dq=a.v;this.$length=a.tail-a.head&a.mask;this.$head=a.head;this.$tail=a.tail;this.$mask=a.mask},iternext:function(){if(!(this.$index>=this.$length)){var a=(0<=this.$index?this.$head:this.$tail)+this.$index&this.$mask;this.$index++;return this.dq[a]}},methods:{__length_hint__:{$meth:function(){return new Sk.builtin.int_(this.$length-\nthis.$index)},$flags:{NoArgs:!0}}}}),y=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",{constructor:function(a){this.$index=(a.tail-a.head&a.mask)-1;this.dq=a.v;this.$head=a.head;this.$mask=a.mask},iternext:function(){if(!(0>this.$index)){var a=this.$head+this.$index&this.$mask;this.$index--;return this.dq[a]}},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),u=new RegExp(/^[0-9].*/),t=new RegExp(/^[0-9_].*/),q=new RegExp(/^\\w*$/),v=/,/g,w=/\\s+/;n.co_argcount=\n2;n.co_kwonlyargcount=3;n.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$];n.co_varnames=[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"];f.namedtuple=new Sk.builtin.func(n);return f};\n",
  "src/lib/functools.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(f){var k=0;return function(){return k<f.length?{done:!1,value:f[k++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.makeIterator=function(f){var k=\"undefined\"!=typeof Symbol&&Symbol.iterator&&f[Symbol.iterator];return k?k.call(f):$jscomp.arrayIterator(f)};$jscomp.arrayFromIterator=function(f){for(var k,u=[];!(k=f.next()).done;)u.push(k.value);return u};\n$jscomp.arrayFromIterable=function(f){return f instanceof Array?f:$jscomp.arrayFromIterator($jscomp.makeIterator(f))};function $builtinmodule(){var f={};return Sk.misceval.chain(Sk.importModule(\"collections\",!1,!0),function(k){f._namedtuple=k.$d.namedtuple;return functools_mod(f)})}\nfunction functools_mod(f){function k(a){return new g(function(){throw new ca(a+\" is not yet implemented in skulpt\");})}function u(a,b){b||(b=J);if(K(a))a=L(a,M),0>a&&(a=0);else{if(v(a)&&da(b)){var c=a;a=128;var e=new C(c,a,b);e.tp$setattr(N,new g(function(){return y({maxsize:a,typed:b})}));return m(f.update_wrapper,[e,c])}if(!O(a))throw new p(\"Expected first argument to be an integer, a callable, or None\");}return new g(function(c){var e=new C(c,a,b);e.tp$setattr(N,new g(function(){return y({maxsize:a,\ntyped:b})}));return m(f.update_wrapper,[e,c])})}function ea(a,b){var c=this,e=P(a,b,this.typed),d=this.cache.mp$lookup(e);if(void 0!==d)return this.hits++,d;this.misses++;return w(m(this.func,a,b),function(a){c.cache.mp$ass_subscript(e,a);return a})}function fa(a,b){this.misses++;return m(this.func,a,b)}function ha(a,b){var c=this,e=P(a,b,this.typed),d=this.cache.mp$lookup(e);if(void 0!==d)return a=d.result,Q(d),D(this,d),this.hits++,a;this.misses++;return w(m(this.func,a,b),function(a){if(void 0!==\nc.cache.mp$lookup(e))return a;if(c.cache.get$size()<c.maxsize||c.root.next===c.root){var b={key:e,result:a};c.cache.mp$ass_subscript(e,b);D(c,b);return a}b=c.root.next;Q(b);if(void 0===c.cache.pop$item(b.key)){a=c.root;var d=a.next;d.prev=a.next=b;b.prev=a;b.next=d;throw new ia(\"cached item removed unexpectedly\");}b.key=e;b.result=a;c.cache.mp$ass_subscript(e,b);D(c,b);return a})}function Q(a){var b=a.next;a.prev.next=a.next;b.prev=a.prev}function D(a,b){a=a.root;var c=a.prev;c.next=a.prev=b;b.prev=\nc;b.next=a}function P(a,b,c){var e=a.slice(0),d=[];if(b&&b.length){e.push(ja);for(var f=0;f<b.length;f+=2){var g=b[f+1];d.push(g);e.push(new t([new h(b[f]),g]))}}if(R(c))e.push.apply(e,[].concat($jscomp.arrayFromIterable(a.map(function(a){return a.ob$type})),$jscomp.arrayFromIterable(d.map(function(a){return a.ob$type}))));else if(1===e.length&&ka.has(e[0].ob$type))return e[0];return new la(e)}function S(a,b){a=this.arg_arr.concat(a);if(b){b=T(b);var c=this.kwdict.dict$copy();c.dict$merge(b);b=U(c)}else b=\nU(this.kwdict);return{args:a,kwargs:b}}function V(a,b){if(1>a.length)throw new p(\"type 'partial' takes at least 1 argument\");var c=a.shift();if(c instanceof this.sk$builtinBase){var e=c;c=e.fn;var d=e.arg_arr;e=e.kwdict}this.check$func(c);d&&(a=d.concat(a));b=b||[];b=T(b);e&&(d=e.dict$copy(),d.dict$merge(b),b=d);if(this.sk$builtinBase===this.constructor)return new this.constructor(c,a,b);d=new this.constructor;this.sk$builtinBase.call(d,c,a,b);return d}function W(){if(this.in$repr)return new h(\"...\");\nthis.in$repr=!0;var a=[z(this.fn)];this.arg_arr.forEach(function(b){a.push(z(b))});this.kwdict.$items().forEach(function(b){var c=$jscomp.makeIterator(b);b=c.next().value;c=c.next().value;a.push(b.toString()+\"=\"+z(c))});this.in$repr=!1;return new h(this.tp$name+\"(\"+a.join(\", \")+\")\")}function n(a,b){function c(a,c){var d=E(a.tp$getattr(e),[c]);if(d===ma)return d;d=R(d);return new na(b(d,a,c))}var e=X[a];c.co_name=e;return c}var d=Sk.builtin,Y=d.object,F=d.int_,h=d.str,G=d.list,t=d.tuple,A=d.dict,B=\nd.none.none$,J=d.bool.false$,ma=d.NotImplemented.NotImplemented$,na=d.bool,g=d.func,oa=d.method,p=d.TypeError,ia=d.RuntimeError,pa=d.ValueError,ca=d.NotImplementedError,qa=d.AttributeErrror,M=d.OverflowError,O=d.checkNone,da=d.checkBool,v=d.checkCallable,ra=d.checkClass;d=Sk.misceval;var E=d.callsimArray,m=d.callsimOrSuspendArray,sa=d.iterFor,w=d.chain,K=d.isIndex,L=d.asIndexSized,R=d.isTrue,q=d.richCompareBool,z=d.objectRepr,y=Sk.ffi.remapToPy,l=Sk.abstr;d=l.buildNativeClass;var ta=l.setUpModuleMethods,\nU=l.keywordArrayFromPyDict,T=l.keywordArrayToPyDict,ua=l.objectHash,va=l.lookupSpecial,Z=l.copyKeywordsToNamedArgs,wa=l.typeName,H=l.iter,aa=l.gattr,r=Sk.generic,x=r.getSetDict;l=r.getAttr;r=r.setAttr;Object.assign(f,{__name__:new h(\"functools\"),__doc__:new h(\"Tools for working with functions and callable objects\"),__all__:new G(\"update_wrapper wraps WRAPPER_ASSIGNMENTS WRAPPER_UPDATES total_ordering cmp_to_key cache lru_cache reduce partial partialmethod singledispatch singledispatchmethod cached_property\".split(\" \").map(function(a){return new h(a)})),\nWRAPPER_ASSIGNMENTS:new t([\"__module__\",\"__name__\",\"__qualname__\",\"__doc__\"].map(function(a){return new h(a)})),WRAPPER_UPDATES:new t([new h(\"__dict__\")]),singledispatch:k(\"singledispatch\"),singledispatchmethod:k(\"singledispatchmethod\"),cached_property:k(\"cached_property\")});var N=new h(\"cache_parameters\"),xa=f._CacheInfo=E(f._namedtuple,[\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"]].map(function(a){return y(a)}),[\"module\",new h(\"functools\")]),C=d(\"functools._lru_cache_wrapper\",{constructor:function(a,\nb,c,e){if(!v(a))throw new p(\"the first argument must be callable\");if(O(b))e=ea,b=-1;else if(K(b))b=L(b,M),0>b&&(b=0),e=0===b?fa:ha;else throw new p(\"maxsize should be integer or None\");this.root={};this.root.prev=this.root.next=this.root;this.wrapper=e;this.maxsize=b;this.typed=c;this.cache=new A([]);this.func=a;this.misses=this.hits=0;this.$d=new A([])},slots:{tp$new:function(a,b){var c=$jscomp.makeIterator(Z(\"_lru_cache_wrapper\",[\"user_function\",\"maxsize\",\"typed\",\"cache_info_type\"],a,b));a=c.next().value;\nb=c.next().value;var e=c.next().value;c=c.next().value;return new C(a,b,e,c)},tp$call:function(a,b){return this.wrapper(a,b)},tp$descr_get:function(a,b){return null===a?this:new oa(this,a)},tp$doc:\"Create a cached callable that wraps another function.\\n\\nuser_function:      the function being cached\\n\\nmaxsize:  0         for no caching\\n          None      for unlimited cache size\\n          n         for a bounded cache\\n\\ntyped:    False     cache f(3) and f(3.0) as identical calls\\n          True      cache f(3) and f(3.0) as distinct calls\\n\\ncache_info_type:    namedtuple class with the fields:\\n                        hits misses currsize maxsize\\n\"},\nmethods:{cache_info:{$meth:function(){return m(xa,[this.hits,this.misses,-1===this.maxsize?B:this.maxsize,this.cache.get$size()].map(function(a){return y(a)}))},$flags:{NoArgs:!0},$doc:\"Report cache statistics\"},cache_clear:{$meth:function(){this.hits=this.misses=0;this.root={};this.root.next=this.root.prev=this.root;return m(this.cache.tp$getattr(new h(\"clear\"),!0))},$flags:{NoArgs:!0},$doc:\"Clear the cache and cache statistics\"},__deepcopy__:{$meth:function(a){return this},$flags:{OneArg:!0}},__copy__:{$meth:function(){return this},\n$flags:{NoArgs:!0}}},getsets:{__dict__:x}}),la=d(\"_HachedSeq\",{base:G,constructor:function(a){this.$hashval=ua(new t(a));G.call(this,a)},slots:{tp$hash:function(){return this.$hashval}}}),ja=new Y,ka=new Set([F,h]);f.partial=d(\"functools.partial\",{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new t(b);this.kwdict=c;this.in$repr=!1;this.$d=new A([])},slots:{tp$new:V,tp$call:function(a,b){b=this.adj$args_kws(a,b);a=b.args;b=b.kwargs;return this.fn.tp$call(a,b)},tp$doc:\"partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n\",\n$r:W,tp$getattr:l,tp$setattr:r},getsets:{func:{$get:function(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get:function(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get:function(){return this.kwdict},$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:x},methods:{},proto:{adj$args_kws:S,check$func:function(a){if(!v(a))throw new p(\"the first argument must be callable\");}}});f.partialmethod=d(\"functools.partialmethod\",\n{constructor:function(a,b,c){this.fn=a;this.arg_arr=b;this.arg_tup=new t(b);this.kwdict=c},slots:{tp$new:V,tp$doc:\"Method descriptor with partial application of the given arguments\\n    and keywords.\\n\\n    Supports wrapping existing descriptors and handles non-descriptor\\n    callables as instance methods.\\n    \",$r:W,tp$descr_get:function(a,b){if(this.fn.tp$descr_get){var c=this.fn.tp$descr_get(a,b);if(c!==this.fn){if(!v(c))throw new p(\"type 'partial' requires a callable\");var e=new f.partial(c,\nthis.arg_arr.slice(0),this.kwdict.dict$copy());c=va(c,this.str$self);void 0!==c&&e.tp$setattr(this.str$self,c)}}void 0===e&&(e=this.make$unbound().tp$descr_get(a,b));return e}},methods:{_make_unbound_method:{$meth:function(){return this.make$unbound()},$flags:{NoArgs:!0}}},getsets:{func:{$get:function(){return this.fn},$doc:\"function object to use in future partial calls\"},args:{$get:function(){return this.arg_tup},$doc:\"tuple of arguments to future partial calls\"},keywords:{$get:function(){return this.kwdict},\n$doc:\"dictionary of keyword arguments to future partial calls\"},__dict__:x},proto:{str$self:new h(\"__self__\"),make$unbound:function(){function a(a,e){var c=a.shift();e=b.adj$args_kws(a,e);a=e.args;e=e.kwargs;a.unshift(c);return m(b.fn,a,e)}var b=this;a.co_fastcall=!0;return new g(a)},adj$args_kws:S,check$func:function(a){if(!v(a)&&void 0===a.tp$descr_get)throw new p(z(a)+\" is not callable or a descriptor\");}}});var X={__lt__:h.$lt,__le__:h.$le,__gt__:h.$gt,__ge__:h.$ge};x=n(\"__lt__\",function(a,b,\nc){return!a&&q(b,c,\"NotEq\")});r=n(\"__lt__\",function(a,b,c){return a||q(b,c,\"Eq\")});var ya=n(\"__lt__\",function(a){return!a}),za=n(\"__le__\",function(a,b,c){return!a||q(b,c,\"Eq\")}),Aa=n(\"__le__\",function(a,b,c){return a&&q(b,c,\"NotEq\")}),Ba=n(\"__le__\",function(a){return!a}),Ca=n(\"__gt__\",function(a,b,c){return!a&&q(b,c,\"NotEq\")}),Da=n(\"__gt__\",function(a,b,c){return a||q(b,c,\"Eq\")}),Ea=n(\"__gt__\",function(a){return!a}),Fa=n(\"__ge__\",function(a,b,c){return!a||q(b,c,\"Eq\")}),Ga=n(\"__ge__\",function(a,b,\nc){return a&&q(b,c,\"NotEq\")}),Ha=n(\"__ge__\",function(a){return!a}),ba={__lt__:{__gt__:new g(x),__le__:new g(r),__ge__:new g(ya)},__le__:{__ge__:new g(za),__lt__:new g(Aa),__gt__:new g(Ba)},__gt__:{__lt__:new g(Ca),__ge__:new g(Da),__le__:new g(Ea)},__ge__:{__le__:new g(Fa),__gt__:new g(Ga),__lt__:new g(Ha)}},Ia={__lt__:\"ob$lt\",__le__:\"ob$le\",__gt__:\"ob$gt\",__ge__:\"ob$ge\"},Ja=new F(0),I=d(\"functools.KeyWrapper\",{constructor:function(a,b){this.cmp=a;this.obj=b},slots:{tp$call:function(a,b){a=$jscomp.makeIterator(Z(\"K\",\n[\"obj\"],a,b,[])).next().value;return new I(this.cmp,a)},tp$richcompare:function(a,b){if(!(a instanceof I))throw new p(\"other argument must be K instance\");var c=this.obj;a=a.obj;if(!c||!a)throw new qa(\"object\");c=m(this.cmp,[c,a]);return w(c,function(a){return q(a,Ja,b)})},tp$getattr:l,tp$hash:B},getsets:{obj:{$get:function(){return this.obj||B},$set:function(a){this.obj=a},$doc:\"Value wrapped by a key function.\"}}}),Ka=new h(\"update\"),La=new h(\"__wrapped__\");ta(\"functools\",f,{cache:{$meth:function(a){return m(u(B),\n[a])},$flags:{OneArg:!0},$doc:'Simple lightweight unbounded cache.  Sometimes called \"memoize\".',$textsig:\"($module, user_function, /)\"},lru_cache:{$meth:u,$flags:{NamedArgs:[\"maxsize\",\"typed\"],Defaults:[new F(128),J]},$doc:\"Least-recently-used cache decorator.\\n\\nIf *maxsize* is set to None, the LRU features are disabled and the cache\\ncan grow without bound.\\n\\nIf *typed* is True, arguments of different types will be cached separately.\\nFor example, f(3.0) and f(3) will be treated as distinct calls with\\ndistinct results.\\n\\nArguments to the cached function must be hashable.\\n\\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\\nAccess the underlying function with f.__wrapped__.\\n\\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\"},\ncmp_to_key:{$meth:function(a){return new I(a)},$flags:{NamedArgs:[\"mycmp\"],Defaults:[]},$doc:\"Convert a cmp= function into a key= function.\",$textsig:\"($module, cmp, /)\"},reduce:{$meth:function(a,b,c){var e=H(b),d;c=c||e.tp$iternext(!0);return w(c,function(b){if(void 0===b)throw new p(\"reduce() of empty sequence with no initial value\");d=b;return sa(e,function(b){return w(m(a,[d,b]),function(a){d=a})})},function(){return d})},$flags:{MinArgs:2,MaxArgs:3},$doc:\"reduce(function, sequence[, initial]) -> value\\n\\nApply a function of two arguments cumulatively to the items of a sequence,\\nfrom left to right, so as to reduce the sequence to a single value.\\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\nof the sequence in the calculation, and serves as a default when the\\nsequence is empty.\",\n$textsig:\"($module, function, sequence[, initial], /)\"},total_ordering:{$meth:function(a){var b=[];if(!ra(a))throw new p(\"total ordering only supported for type objects not '\"+wa(a)+\"'\");Object.keys(ba).forEach(function(c){var e=Ia[c];a.prototype[e]!==Y.prototype[e]&&b.push(c)});if(!b.length)throw new pa(\"must define atleast one ordering operation: <, >, <=, >=\");Object.entries(ba[b[0]]).forEach(function(c){var e=$jscomp.makeIterator(c);c=e.next().value;e=e.next().value;b.includes(c)||a.tp$setattr(X[c],\ne)});return a},$flags:{OneArg:!0},$doc:\"Class decorator that fills in missing ordering methods\"},update_wrapper:{$meth:function(a,b,c,e){c=H(c);for(var d,f=c.tp$iternext();void 0!==f;f=c.tp$iternext())void 0!==(d=b.tp$getattr(f))&&a.tp$setattr(f,d);c=H(e);for(e=c.tp$iternext();void 0!==e;e=c.tp$iternext())d=b.tp$getattr(e)||new A([]),e=aa(a,e),e=aa(e,Ka),E(e,[d]);a.tp$setattr(La,b);return a},$flags:{NamedArgs:[\"wrapper\",\"wrapped\",\"assigned\",\"updated\"],Defaults:[f.WRAPPER_ASSIGNMENTS,f.WRAPPER_UPDATES]},\n$doc:\"Update a wrapper function to look like the wrapped function\\n\\n       wrapper is the function to be updated\\n       wrapped is the original function\\n       assigned is a tuple naming the attributes assigned directly\\n       from the wrapped function to the wrapper function (defaults to\\n       functools.WRAPPER_ASSIGNMENTS)\\n       updated is a tuple naming the attributes of the wrapper that\\n       are updated with the corresponding attribute from the wrapped\\n       function (defaults to functools.WRAPPER_UPDATES)\\n    \",\n$textsig:\"($module, /, wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"},wraps:{$meth:function(a,b,c){return m(f.partial,[f.update_wrapper],[\"wrapped\",a,\"assigned\",b,\"updated\",c])},$flags:{NamedArgs:[\"wrapped\",\"assigned\",\"updated\"],Defaults:[f.WRAPPER_ASSIGNMENTS,f.WRAPPER_UPDATES]},$doc:\"Decorator factory to apply update_wrapper() to a wrapper function\\n\\n       Returns a decorator that invokes update_wrapper() with the decorated\\n       function as the wrapper argument and the arguments to wraps() as the\\n       remaining arguments. Default arguments are as for update_wrapper().\\n       This is a convenience function to simplify applying partial() to\\n       update_wrapper().\\n    \",\n$textsig:\"($module, /, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))\"}});return f};\n",
  "src/lib/itertools.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(f){var g=0;return function(){return g<f.length?{done:!1,value:f[g++]}:{done:!0}}};$jscomp.arrayIterator=function(f){return{next:$jscomp.arrayIteratorImpl(f)}};$jscomp.makeIterator=function(f){var g=\"undefined\"!=typeof Symbol&&Symbol.iterator&&f[Symbol.iterator];return g?g.call(f):$jscomp.arrayIterator(f)};$jscomp.arrayFromIterator=function(f){for(var g,d=[];!(g=f.next()).done;)d.push(g.value);return d};\n$jscomp.arrayFromIterable=function(f){return f instanceof Array?f:$jscomp.arrayFromIterator($jscomp.makeIterator(f))};\nvar $builtinmodule=function(f){function g(a,b,c){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(a.tp$name,[\"iterable\",\"r\"],b,c,[]));c=b.next().value;b=b.next().value;c=Sk.misceval.arrayFromIterable(c);b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===a)return new a.constructor(c,b);var d=new this.constructor;a.constructor.call(d,c,b);return d}var d={};d.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",\n{constructor:function(a,b,c){var d=this;this.iter=a;this.func=b;this.total=c;this.tp$iternext=function(){d.total=Sk.builtin.checkNone(d.total)?d.iter.tp$iternext():d.total;d.tp$iternext=d.constructor.prototype.tp$iternext;return d.total}},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a)return this.total=Sk.misceval.callsimArray(this.func,[this.total,a])},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --\\x3e accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",\ntp$new:function(a,b){Sk.abstr.checkArgsLen(\"accumulate\",a,0,2);var c=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],a,b,[Sk.builtin.none.none$,Sk.builtin.none.none$]));a=c.next().value;b=c.next().value;c=c.next().value;a=Sk.abstr.iter(a);b=Sk.builtin.checkNone(b)?new Sk.builtin.func(function(a,b){return Sk.abstr.numberBinOp(a,b,\"Add\")}):b;if(this===d.accumulate.prototype)return new d.accumulate(a,b,c);var e=new this.constructor;d.accumulate.call(e,\na,b,c);return e}}});d.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function(a){var b=this;this.iterables=a;this.current_it=null;this.tp$iternext=function(){b.tp$iternext=b.constructor.prototype.tp$iternext;b.current_it=b.iterables.tp$iternext();if(void 0===b.current_it)b.tp$iternext=function(){};else return b.current_it=Sk.abstr.iter(b.current_it),b.tp$iternext()}},iternext:function(a){for(var b;void 0===b;)if(b=this.current_it.tp$iternext(),void 0===b){this.current_it=this.iterables.tp$iternext();\nif(void 0===this.current_it){this.tp$iternext=function(){};break}this.current_it=Sk.abstr.iter(this.current_it)}else return b},slots:{tp$doc:\"chain(*iterables) --\\x3e chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"chain\",b);a=(new Sk.builtin.tuple(a.slice(0))).tp$iter();if(this===d.chain.prototype)return new d.chain(a);\nb=new this.constructor;d.chain.call(b,a);return b}},classmethods:{from_iterable:{$meth:function(a){a=Sk.abstr.iter(a);return new d.chain(a)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --\\x3e chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}}});d.combinations=Sk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;this.indices=Array(b).fill().map(function(a,b){return b});\nthis.n=a.length;this.tp$iternext=function(){if(!(c.r>c.n))return c.tp$iternext=c.constructor.prototype.tp$iternext,new Sk.builtin.tuple(c.pool.slice(0,c.r))}},iternext:function(a){var b=this,c=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=a+this.n-this.r){c=!0;break}if(c){this.indices[a]++;for(a+=1;a<this.r;a++)this.indices[a]=this.indices[a-1]+1;a=this.indices.map(function(a){return b.pool[a]});return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations(iterable, r) --\\x3e combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --\\x3e (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",\ntp$new:function(a,b){return g.call(this,d.combinations.prototype,a,b)}}});d.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;this.indices=Array(b).fill(0);this.n=a.length;this.tp$iternext=function(){if(!c.r||c.n){c.tp$iternext=c.constructor.prototype.tp$iternext;var a=c.indices.map(function(a){return c.pool[a]});return new Sk.builtin.tuple(a)}}},iternext:function(a){var b=this,c=!1;for(a=\nthis.r-1;0<=a;a--)if(this.indices[a]!=this.n-1){c=!0;break}if(c){for(c=this.indices[a]+1;a<this.r;a++)this.indices[a]=c;a=this.indices.map(function(a){return b.pool[a]});return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --\\x3e combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --\\x3e AA AB AC BB BC CC\",\ntp$new:function(a,b){return g.call(this,d.combinations_with_replacement.prototype,a,b)}}});d.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function(a,b){this.data=a;this.selectors=b},iternext:function(){for(var a=this.data.tp$iternext(),b=this.selectors.tp$iternext();void 0!==a&&void 0!==b;){if(Sk.misceval.isTrue(b))return a;a=this.data.tp$iternext();b=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --\\x3e iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],a,b,[]));a=b.next().value;b=b.next().value;a=Sk.abstr.iter(a);b=Sk.abstr.iter(b);if(this===d.count.prototype)return new d.compress(a,b);var c=new this.constructor;d.compress.call(c,a,b);return c}}});d.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function(a,b){this.start=a;this.step=b},iternext:function(){var a=this.start;this.start=Sk.abstr.numberBinOp(this.start,this.step,\n\"Add\");return a},slots:{tp$doc:\"count(start=0, step=1) --\\x3e count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],a,b,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]));a=b.next().value;b=b.next().value;if(!Sk.builtin.checkNumber(a)&&\n!Sk.builtin.checkComplex(a))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(b)&&!Sk.builtin.checkComplex(b))throw new Sk.builtin.TypeError(\"a number is required\");if(this===d.count.prototype)return new d.count(a,b);var c=new this.constructor;d.count.call(c,a,b);return c},$r:function(){var a=Sk.misceval.objectRepr(this.start),b=Sk.misceval.objectRepr(this.step);b=\"1\"===b?\"\":\", \"+b;return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}}});d.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",\n{constructor:function(a){this.iter=a;this.saved=[];this.consumed=!1;this.i=0;this.length},iternext:function(){if(!this.consumed){var a=this.iter.tp$iternext();if(void 0!==a)return this.saved.push(a),a;this.consumed=!0;this.length=this.saved.length;if(!this.length)return}a=this.saved[this.i];this.i=(this.i+1)%this.length;return a},slots:{tp$doc:\"cycle(iterable) --\\x3e cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new:function(a,\nb){Sk.abstr.checkOneArg(\"cycle\",a,b);a=Sk.abstr.iter(a[0]);if(this===d.cycle.prototype)return new d.cycle(a);b=new this.constructor;d.cycle.call(b,a);return b}}});d.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function(a,b){this.predicate=a;this.iter=b;this.passed},iternext:function(){for(var a=this.iter.tp$iternext();void 0===this.passed&&void 0!==a;){var b=Sk.misceval.callsimArray(this.predicate,[a]);if(!Sk.misceval.isTrue(b)){this.passed=!0;break}a=this.iter.tp$iternext()}return a},\nslots:{tp$doc:\"dropwhile(predicate, iterable) --\\x3e dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"dropwhile\",b);Sk.abstr.checkArgsLen(\"dropwhile\",a,2,2);b=a[0];a=Sk.abstr.iter(a[1]);if(this===d.dropwhile.prototype)return new d.dropwhile(b,a);var c=new this.constructor;d.dropwhile.call(c,b,a);return c}}});d.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",\n{constructor:function(a,b){this.predicate=a;this.iter=b},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a){for(var b=Sk.misceval.callsimArray(this.predicate,[a]);Sk.misceval.isTrue(b);){a=this.iter.tp$iternext();if(void 0===a)return;b=Sk.misceval.callsimArray(this.predicate,[a])}return a}},slots:{tp$doc:\"filterfalse(function or None, sequence) --\\x3e filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",\ntp$new:function(a,b){Sk.abstr.checkNoKwargs(\"filterfalse\",b);Sk.abstr.checkArgsLen(\"filterfalse\",a,2,2);b=Sk.builtin.checkNone(a[0])?Sk.builtin.bool:a[0];a=Sk.abstr.iter(a[1]);if(this===d.filterfalse.prototype)return new d.filterfalse(b,a);var c=new this.constructor;d.filterfalse.call(c,b,a);return c}}});d._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function(a,b){this.groupby=a;this.tgtkey=a.tgtkey;this.id=a.id},iternext:function(a){a=Sk.misceval.richCompareBool(this.groupby.currkey,\nthis.tgtkey,\"Eq\");if(this.groupby.id===this.id&&a)return a=this.groupby.currval,this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),a}});d.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function(a,b){this.iter=a;this.keyf=b;this.currval;this.currkey=this.tgtkey=new Sk.builtin.object;this.id},iternext:function(a){this.id={};for(a=Sk.misceval.richCompareBool(this.currkey,\nthis.tgtkey,\"Eq\");a;){this.currval=this.iter.tp$iternext();if(void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]);a=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;a=new d._grouper(this);return new Sk.builtin.tuple([this.currkey,a])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],a,b,[Sk.builtin.none.none$]));a=b.next().value;b=b.next().value;a=Sk.abstr.iter(a);b=Sk.builtin.checkNone(b)?new Sk.builtin.func(function(a){return a}):b;if(this===d.groupby.prototype)return new d.groupby(a,b);var c=new this.constructor;d.groupby.call(c,a,b);return c}}});d.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function(a,b,c,d){var e=this;this.iter=a;this.previt=b;\nthis.stop=c;this.step=d;this.tp$iternext=function(){e.tp$iternext=e.constructor.prototype.tp$iternext;if(e.previt>=e.stop)for(var a=0;a<e.stop;a++)e.iter.tp$iternext();else{for(a=0;a<e.previt;a++)e.iter.tp$iternext();return e.iter.tp$iternext()}}},iternext:function(a){if(this.previt+this.step>=this.stop)for(a=this.previt+1;a<this.stop;a++)this.previt+=this.step,this.iter.tp$iternext();else{for(a=this.previt+1;a<this.previt+this.step;a++)this.iter.tp$iternext();this.previt+=this.step;return this.iter.tp$iternext()}},\nslots:{tp$doc:\"islice(iterable, stop) --\\x3e islice object\\nislice(iterable, start, stop[, step]) --\\x3e islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",tp$new:function(a,\nb){Sk.abstr.checkNoKwargs(\"islice\",b);Sk.abstr.checkArgsLen(\"islice\",a,2,4);b=Sk.abstr.iter(a[0]);var c=a[1],e=a[2];a=a[3];void 0===e?(e=c,a=c=Sk.builtin.none.none$):void 0===a&&(a=Sk.builtin.none.none$);if(Sk.builtin.checkNone(e)||Sk.misceval.isIndex(e)){if(e=Sk.builtin.checkNone(e)?Number.MAX_SAFE_INTEGER:Sk.misceval.asIndexSized(e),0>e||e>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");\nif(Sk.builtin.checkNone(c)||Sk.misceval.isIndex(c)){if(c=Sk.builtin.checkNone(c)?0:Sk.misceval.asIndexSized(c),0>c||c>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");}else throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(Sk.builtin.checkNone(a)||Sk.misceval.isIndex(a)){if(a=Sk.builtin.checkNone(a)?1:Sk.misceval.asIndexSized(a),0>=a||a>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");\n}else throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");if(this===d.islice.prototype)return new d.islice(b,c,e,a);var f=new this.constructor;d.islice.call(f,b,c,e,a);return f}}});d.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function(a,b){var c=this;this.pool=a;this.r=b;var d=a.length;this.indices=Array(d).fill().map(function(a,b){return b});this.cycles=Array(b).fill().map(function(a,b){return d-b});this.n=d;this.tp$iternext=\nfunction(){if(!(c.r>c.n))return c.tp$iternext=c.constructor.prototype.tp$iternext,new Sk.builtin.tuple(c.pool.slice(0,c.r))}},iternext:function(a){var b=this;for(a=this.r-1;0<=a;a--)if(this.cycles[a]--,0==this.cycles[a])this.indices.push(this.indices.splice(a,1)[0]),this.cycles[a]=this.n-a;else{var c=this.cycles[a],d=$jscomp.makeIterator([this.indices[this.n-c],this.indices[a]]);this.indices[a]=d.next().value;this.indices[this.n-c]=d.next().value;a=this.indices.map(function(a){return b.pool[a]}).slice(0,\nthis.r);return new Sk.builtin.tuple(a)}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --\\x3e permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --\\x3e (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",tp$new:function(a,b){a=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],a,b,[Sk.builtin.none.none$]));b=a.next().value;a=a.next().value;b=Sk.misceval.arrayFromIterable(b);a=Sk.builtin.checkNone(a)?\nb.length:Sk.misceval.asIndexSized(a,Sk.builtin.OverFlowError);if(0>a)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===d.permutations.prototype)return new d.permutations(b,a);var c=new this.constructor;d.permutations.call(c,b,a);return c}}});d.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function(a){var b=this;this.pools=a;this.n=a.length;this.indices=Array(a.length).fill(0);this.pool_sizes=a.map(function(a){return a.length});this.tp$iternext=function(){b.tp$iternext=\nb.constructor.prototype.tp$iternext;var a=b.indices.map(function(a,c){return b.pools[c][b.indices[c]]});if(a.some(function(a){return void 0===a}))b.n=0;else return new Sk.builtin.tuple(a)}},iternext:function(a){var b=this;for(a=this.n-1;0<=a&&a<this.n;)this.indices[a]++,this.indices[a]>=this.pool_sizes[a]?(this.indices[a]=-1,a--):a++;if(!this.n||this.indices.every(function(a){return-1===a}))this.n=0;else return a=this.indices.map(function(a,d){return b.pools[d][b.indices[d]]}),new Sk.builtin.tuple(a)},\nslots:{tp$doc:\"product(*iterables, repeat=1) --\\x3e product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --\\x3e ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --\\x3e (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],b,[new Sk.builtin.int_(1)])).next().value;b=Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError);if(0>b)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");for(var c=[],e=0;e<a.length;e++)c.push(Sk.misceval.arrayFromIterable(a[e]));a=[].concat.apply([],$jscomp.arrayFromIterable(Array(b).fill(c)));if(this===d.product.prototype)return new d.product(a);b=new this.constructor;d.product.call(b,\na);return b}}});d.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",{constructor:function(a,b){var c=this;this.object=a;this.times=b;void 0===b&&(this.tp$iternext=function(){return c.object})},iternext:function(a){return 0<this.times--?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",\n[\"object\",\"times\"],a,b,[null]));a=b.next().value;b=b.next().value;b=null!==b?Sk.misceval.asIndexSized(b,Sk.builtin.OverFlowError):void 0;if(this===d.repeat.prototype)return new d.repeat(a,b);var c=new this.constructor;d.repeat.call(c,a,b);return c},$r:function(){var a=Sk.misceval.objectRepr(this.object),b=void 0===this.times?\"\":\", \"+(0<=this.times?this.times:0);return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}},methods:{__lenght_hint__:{$meth:function(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");\nreturn new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}});d.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",{constructor:function(a,b){this.func=a;this.iter=b},iternext:function(a){a=this.iter.tp$iternext();if(void 0!==a)return a=Sk.misceval.arrayFromIterable(a),Sk.misceval.callsimArray(this.func,a)},slots:{tp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],a,b,[]));a=b.next().value;b=b.next().value;b=Sk.abstr.iter(b);\na=Sk.builtin.checkNone(a)?Sk.builtin.bool:a;if(this===d.starmap.prototype)return new d.starmap(a,b);var c=new this.constructor;d.starmap.call(c,a,b);return c}}});d.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",{constructor:function(a,b){this.predicate=a;this.iter=b},iternext:function(){var a=this.iter.tp$iternext();if(void 0!==a){var b=Sk.misceval.callsimArray(this.predicate,[a]);if(Sk.misceval.isTrue(b))return a;this.tp$iternext=function(){}}},slots:{tp$doc:\"takewhile(predicate, iterable) --\\x3e takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",\ntp$new:function(a,b){Sk.abstr.checkNoKwargs(\"takewhile\",b);Sk.abstr.checkArgsLen(\"takewhile\",a,2,2);b=a[0];a=Sk.abstr.iter(a[1]);if(this===d.takewhile.prototype)return new d.takewhile(b,a);var c=new this.constructor;d.takewhile.call(c,b,a);return c}}});d.tee=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\");});d.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function(a,b){this.iters=a;this.fillvalue=b;this.active=\nthis.iters.length},iternext:function(a){if(this.active){for(var b=[],c=0;c<this.iters.length;c++){a=this.iters[c].tp$iternext();if(void 0===a){this.active--;if(!this.active)return;this.iters[c]=new d.repeat(this.fillvalue);a=this.fillvalue}b.push(a)}return new Sk.builtin.tuple(b)}},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --\\x3e zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",\ntp$new:function(a,b){b=$jscomp.makeIterator(Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],b,[Sk.builtin.none.none$])).next().value;for(var c=[],e=0;e<a.length;e++)c.push(Sk.abstr.iter(a[e]));if(this===d.zip_longest.prototype)return new d.zip_longest(c,b);a=new this.constructor;d.zip_longest.call(a,c,b);return a}}});d.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\");d.__package__=new Sk.builtin.str(\"\");return d};\n",
  "src/lib/keyword.js": "function $builtinmodule(){var a=Sk,b=a.ffi.remapToPy,c=a.builtin;a=c.frozenset;var d=c.str;c=new d(\"keyword\");var f=b([\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]),e=b(\"False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield\".split(\" \"));b=b([\"_\",\"case\",\"match\"]);var g=(new a(e)).tp$getattr(d.$contains);a=(new a(b)).tp$getattr(d.$contains);return{__name__:c,\n__all__:f,kwlist:e,softkwlist:b,iskeyword:g,issoftkeyword:a}};\n",
  "src/lib/operator.js": "var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.arrayIteratorImpl=function(d){var c=0;return function(){return c<d.length?{done:!1,value:d[c++]}:{done:!0}}};$jscomp.arrayIterator=function(d){return{next:$jscomp.arrayIteratorImpl(d)}};$jscomp.makeIterator=function(d){var c=\"undefined\"!=typeof Symbol&&Symbol.iterator&&d[Symbol.iterator];return c?c.call(d):$jscomp.arrayIterator(d)};$jscomp.arrayFromIterator=function(d){for(var c,a=[];!(c=d.next()).done;)a.push(c.value);return a};\n$jscomp.arrayFromIterable=function(d){return d instanceof Array?d:$jscomp.arrayFromIterator($jscomp.makeIterator(d))};\nfunction $builtinmodule(d){var c={__name__:new Sk.builtin.str(\"operator\"),__doc__:new Sk.builtin.str(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),__all__:new Sk.builtin.list(\"abs add and_ attrgetter concat contains countOf delitem eq floordiv ge getitem gt iadd iand iconcat ifloordiv ilshift imatmul imod imul index indexOf inv invert ior ipow irshift is_ is_not isub itemgetter itruediv ixor le length_hint lshift lt matmul methodcaller mod mul ne neg not_ or_ pos pow rshift setitem sub truediv truth xor\".split(\" \").map(function(a){return new Sk.builtin.str(a)}))};\nc.itemgetter=Sk.abstr.buildNativeClass(\"operator.itemgetter\",{constructor:function(a){this.items=a;this.oneitem=1===a.length;this.item=a[0];this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"itemgetter\",b);Sk.abstr.checkArgsLen(\"itemgetter\",a,1);return new c.itemgetter(a)},tp$call:function(a,b){Sk.abstr.checkNoKwargs(\"itemgetter\",b);Sk.abstr.checkArgsLen(\"itemgetter\",a,1,1);var c=a[0];return this.oneitem?Sk.abstr.objectGetItem(c,this.item,!0):new Sk.builtin.tuple(this.items.map(function(a){return Sk.abstr.objectGetItem(c,\na)}))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",$r:function(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;var a=this.tp$name+\"(\"+this.items.map(function(a){return Sk.misceval.objectRepr(a)}).join(\", \")+\")\";this.in$repr=!1;return a}}});c.attrgetter=Sk.abstr.buildNativeClass(\"operator.attrgetter\",\n{constructor:function(a){this.attrs=a;this.oneattr=1===a.length;this.attr=a[0];this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new:function(a,b){Sk.abstr.checkNoKwargs(\"attrgetter\",b);Sk.abstr.checkArgsLen(\"attrgetter\",a,1);b=[];for(var e=0;e<a.length;e++){var d=a[e];if(!Sk.builtin.checkString(d))throw new Sk.builtin.TypeError(\"attribute name must be a string\");d.v.includes(\".\")?b.push(d.$jsstr().split(\".\").map(function(a){return new Sk.builtin.str(a)})):b.push([d])}return new c.attrgetter(b)},\ntp$call:function(a,b){Sk.abstr.checkNoKwargs(\"attrgetter\",b);Sk.abstr.checkArgsLen(\"attrgetter\",a,1,1);var c=a[0];if(this.oneattr)return this.attr.reduce(function(a,b){return Sk.abstr.gattr(a,b)},c);a=this.attrs.map(function(a){return a.reduce(function(a,b){return Sk.abstr.gattr(a,b)},c)});return new Sk.builtin.tuple(a)},tp$doc:\"attrgetter(attr, ...) --\\x3e attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",\n$r:function(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;var a=this.tp$name+\"(\"+this.items.map(function(a){return Sk.misceval.objectRepr(a)}).join(\", \")+\")\";this.in$repr=!1;return a}}});c.methodcaller=Sk.abstr.buildNativeClass(\"operator.methodcaller\",{constructor:function(a,b,c){this.$name=a;this.args=b;this.kwargs=c||[];this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new:function(a,b){Sk.abstr.checkArgsLen(\"methodcaller\",a,1);var d=a[0];if(!Sk.builtin.checkString(d))throw new Sk.builtin.TypeError(\"method name must be a string\");\nreturn new c.methodcaller(d,a.slice(1),b)},tp$call:function(a,b){var c=this;Sk.abstr.checkNoKwargs(\"methodcaller\",b);Sk.abstr.checkArgsLen(\"methodcaller\",a,1,1);return Sk.misceval.chain(Sk.abstr.gattr(a[0],this.$name,!0),function(a){return Sk.misceval.callsimOrSuspendArray(a,c.args,c.kwargs)})},tp$doc:\"methodcaller(name, ...) --\\x3e methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",\n$r:function(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;var a=[Sk.misceval.objectRepr(this.$name)];a.push.apply(a,$jscomp.arrayFromIterable(this.args.map(function(a){return Sk.misceval.objectRepr(a)})));for(var b=0;b<this.kwargs.length;b+=2)a.push(this.kwargs[b]+\"=\"+Sk.misceval.objectRepr(this.kwargs[b+1]));a=this.tp$name+\"(\"+a.join(\", \")+\")\";this.in$repr=!1;return a}}});Sk.abstr.setUpModuleMethods(\"operator\",c,{lt:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,\nb,\"Lt\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a < b.\"},le:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"LtE\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a <= b.\"},eq:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"Eq\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a == b.\"},ne:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,\nb,\"NotEq\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a != b.\"},ge:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"GtE\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >= b.\"},gt:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"Gt\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a > b.\"},not_:{$meth:function(a){return Sk.abstr.numberUnaryOp(a,\"Not\")},$flags:{OneArg:!0},\n$textsig:\"($module, a, /)\",$doc:\"Same as not a.\"},truth:{$meth:function(a){return Sk.builtin.bool(a)},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Return True if a is true, False otherwise.\"},is_:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"Is\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a is b.\"},is_not:{$meth:function(a,b){return Sk.builtin.bool(Sk.misceval.richCompareBool(a,b,\"IsNot\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",\n$doc:\"Same as a is not b.\"},abs:{$meth:function(a){return Sk.builtin.abs(a)},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as abs(a).\"},add:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a + b.\"},and_:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"BitAnd\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a & b.\"},floordiv:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,\nb,\"FloorDiv\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a // b.\"},index:{$meth:function(a){return new Sk.builtin.int_(Sk.misceval.asIndexOrThrow(a))},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as a.__index__()\"},inv:{$meth:function(a){return Sk.abstr.numberUnaryOp(a,\"Invert\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as ~a.\"},invert:{$meth:function(a){return Sk.abstr.numberUnaryOp(a,\"Invert\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, /)\",\n$doc:\"Same as ~a.\"},lshift:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"LShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a << b.\"},mod:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"Mod\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a % b.\"},mul:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"Mult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a * b.\"},matmul:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,\nb,\"MatMult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a @ b.\"},neg:{$meth:function(a){return Sk.abstr.numberUnaryOp(a,\"USub\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as -a.\"},or_:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"BitOr\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a | b.\"},pos:{$meth:function(a){return Sk.abstr.numberUnaryOp(a,\"UAdd\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as +a.\"},\npow:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"Pow\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ** b.\"},rshift:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"RShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >> b.\"},sub:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"Sub\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a - b.\"},truediv:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,\nb,\"Div\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a / b.\"},xor:{$meth:function(a,b){return Sk.abstr.numberBinOp(a,b,\"BitXor\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ^ b.\"},concat:{$meth:function(a,b){return Sk.abstr.sequenceConcat(a,b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a + b, for a and b sequences.\"},contains:{$meth:function(a,b){return Sk.builtin.bool(Sk.abstr.sequenceContains(a,b))},$flags:{MinArgs:2,\nMaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as b in a (note reversed operands).\"},countOf:{$meth:function(a,b){return Sk.abstr.sequenceGetCountOf(a,b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Return the number of times b occurs in a.\"},delitem:{$meth:function(a,b){return Sk.misceval.chain(Sk.abstr.objectDelItem(a,b,!0),function(){return Sk.builtin.none.none$})},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as del a[b].\"},getitem:{$meth:function(a,\nb){return Sk.abstr.objectGetItem(a,b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a[b].\"},indexOf:{$meth:function(a,b){return Sk.abstr.sequenceGetIndexOf(a,b)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Return the first index of b in a.\"},setitem:{$meth:function(a,b,c){return Sk.misceval.chain(Sk.abstr.objectSetItem(a,b,c,!0),function(){return Sk.builtin.none.none$})},$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\",$doc:\"Same as a[b] = c.\"},\nlength_hint:{$meth:function(a,b){if(void 0===b)b=new Sk.builtin.int_(0);else if(!Sk.builtin.checkInt(b))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(b)+\"' object cannot be interpreted as an integer\");try{return Sk.builtin.len(a)}catch(e){if(!(e instanceof Sk.builtin.TypeError))throw e;}a=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$length_hint);if(void 0!==a){a=Sk.misceval.callsimArray(a,[]);if(a===Sk.builtin.NotImplemented.NotImplemented$)return b;if(!Sk.builtin.checkInteger(a))throw new Sk.builtin.TypeError(\"__length_hint__ must be an integer, not \"+\nSk.abstr.typeName(a));if(a.nb$isnegative())throw new Sk.builtin.TypeError(\"__length_hint__() should return >= 0\");return a}return b},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},iadd:{$meth:function(a,\nb){return Sk.abstr.numberInplaceBinOp(a,b,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a += b.\"},iand:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"BitAnd\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a &= b.\"},iconcat:{$meth:function(a,b){if(void 0!==a.sq$inplace_concat)return a.sq$inplace_concat(b);if(void 0!==a.sq$concat)return a.sq$concat(b);if(!Sk.builtin.checkSequence(a)||!Sk.builtin.checkSequence(b))throw new Sk.builtin.TypeError(Sk.abstr.typeName(a)+\n\" object can't be concatenated\");return Sk.abstr.numberInplaceBinOp(a,b,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a += b, for a and b sequences.\"},ifloordiv:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"FloorDiv\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a //= b.\"},ilshift:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"LShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a <<= b.\"},\nimod:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"Mod\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a %= b.\"},imul:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"Mult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a *= b.\"},imatmul:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"MatMult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a @= b.\"},ior:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,\nb,\"BitOr\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a |= b.\"},ipow:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"Pow\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a **= b.\"},irshift:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"LRhift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >>= b.\"},isub:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"Sub\")},$flags:{MinArgs:2,\nMaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a -= b.\"},itruediv:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"Div\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a /= b.\"},ixor:{$meth:function(a,b){return Sk.abstr.numberInplaceBinOp(a,b,\"BitXor\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ^= b.\"}});Object.assign(c,{__abs__:c.abs,__add__:c.add,__and__:c.and,__concat__:c.concat,__contains__:c.contains,__delitem__:c.delitem,\n__eq__:c.eq,__floordiv__:c.floordiv,__ge__:c.ge,__getitem__:c.getitem,__gt__:c.gt,__iadd__:c.iadd,__iand__:c.iand,__iconcat__:c.iconcat,__ifloordiv__:c.ifloordiv,__ilshift__:c.ilshift,__imatmul__:c.imatmul,__imod__:c.imod,__imul__:c.imul,__index__:c.index,__inv__:c.inv,__invert__:c.invert,__ior__:c.ior,__ipow__:c.ipow,__irshift__:c.irshift,__isub__:c.isub,__itruediv__:c.itruediv,__ixor__:c.ixor,__le__:c.le,__lshift__:c.lshift,__lt__:c.lt,__matmul__:c.matmul,__mod__:c.mod,__mul__:c.mul,__ne__:c.ne,\n__neg__:c.neg,__not__:c.not,__or__:c.or,__pos__:c.pos,__pow__:c.pow,__rshift__:c.rshift,__setitem__:c.setitem,__sub__:c.sub,__truediv__:c.truediv,__xor__:c.xor,_abs:Sk.builtins.abs,div:c.truediv,__div__:c.truediv});return c};\n",
  "src/lib/random.js": "var MersenneTwister=function(b){void 0==b&&(b=(new Date).getTime());this.N=624;this.M=397;this.MATRIX_A=2567483615;this.UPPER_MASK=2147483648;this.LOWER_MASK=2147483647;this.mt=Array(this.N);this.mti=this.N+1;this.init_genrand(b)};MersenneTwister.prototype.init_genrand=function(b){this.mt[0]=b>>>0;for(this.mti=1;this.mti<this.N;this.mti++)b=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(1812433253*((b&4294901760)>>>16)<<16)+1812433253*(b&65535)+this.mti,this.mt[this.mti]>>>=0};\nMersenneTwister.prototype.init_by_array=function(b,f){var e;this.init_genrand(19650218);var g=1;var h=0;for(e=this.N>f?this.N:f;e;e--){var a=this.mt[g-1]^this.mt[g-1]>>>30;this.mt[g]=(this.mt[g]^(1664525*((a&4294901760)>>>16)<<16)+1664525*(a&65535))+b[h]+h;this.mt[g]>>>=0;g++;h++;g>=this.N&&(this.mt[0]=this.mt[this.N-1],g=1);h>=f&&(h=0)}for(e=this.N-1;e;e--)a=this.mt[g-1]^this.mt[g-1]>>>30,this.mt[g]=(this.mt[g]^(1566083941*((a&4294901760)>>>16)<<16)+1566083941*(a&65535))-g,this.mt[g]>>>=0,g++,g>=\nthis.N&&(this.mt[0]=this.mt[this.N-1],g=1);this.mt[0]=2147483648};\nMersenneTwister.prototype.genrand_int32=function(){var b=[0,this.MATRIX_A];if(this.mti>=this.N){var f;this.mti==this.N+1&&this.init_genrand(5489);for(f=0;f<this.N-this.M;f++){var e=this.mt[f]&this.UPPER_MASK|this.mt[f+1]&this.LOWER_MASK;this.mt[f]=this.mt[f+this.M]^e>>>1^b[e&1]}for(;f<this.N-1;f++)e=this.mt[f]&this.UPPER_MASK|this.mt[f+1]&this.LOWER_MASK,this.mt[f]=this.mt[f+(this.M-this.N)]^e>>>1^b[e&1];e=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK;this.mt[this.N-1]=this.mt[this.M-\n1]^e>>>1^b[e&1];this.mti=0}e=this.mt[this.mti++];e^=e>>>11;e^=e<<7&2636928640;e^=e<<15&4022730752;return(e^e>>>18)>>>0};MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1};MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)};MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)};MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)};\nMersenneTwister.prototype.genrand_res53=function(){var b=this.genrand_int32()>>>5,f=this.genrand_int32()>>>6;return 1.1102230246251565E-16*(67108864*b+f)};\nvar $builtinmodule=function(b){b={};var f=new MersenneTwister,e=void 0;b.seed=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1);a=Sk.builtin.asnum$(a);f=0<arguments.length?new MersenneTwister(a):new MersenneTwister;return Sk.builtin.none.none$});b.random=new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0);return new Sk.builtin.float_(f.genrand_res53())});var g=function(a,c,d){if(!Sk.builtin.checkInt(a))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\nif(void 0===c)return a=f.genrand_res53()*a|0,new Sk.builtin.int_(a);if(!Sk.builtin.checkInt(c))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");void 0===d&&(d=1);var b=c-a;if(1==d&&0<b)return a+=f.genrand_res53()*b|0,new Sk.builtin.int_(a);if(1==d)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+a+\", \"+c+\", \"+b+\")\");if(!Sk.builtin.checkInt(d))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(0<d)c=(b+d-1)/d|0;else if(0>d)c=(b+d+1)/d|0;else throw new Sk.builtin.ValueError(\"zero step for randrange()\");\nif(0>=c)throw new Sk.builtin.ValueError(\"empty range for randrange()\");a+=d*(f.genrand_res53()*c|0);return new Sk.builtin.int_(a)};b.randint=new Sk.builtin.func(function(a,c){Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2);a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);return g(a,c+1)});b.randrange=new Sk.builtin.func(function(a,c,d){Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3);a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);d=Sk.builtin.asnum$(d);return g(a,c,d)});b.uniform=\nnew Sk.builtin.func(function(a,c){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2);a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);var d=f.genrand_res53();return new Sk.builtin.float_(a+d*(c-a))});b.triangular=new Sk.builtin.func(function(a,c,d){Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3);Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(c));a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);if(a>c){var b=\na;a=c;c=b}void 0===d||d===Sk.builtin.none.none$?d=(c-a)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(d)),d=Sk.builtin.asnum$(d));b=f.genrand_res53();return new Sk.builtin.float_(b<(d-a)/(c-a)?a+Math.sqrt(b*(c-a)*(d-a)):c-Math.sqrt((1-b)*(c-a)*(c-d)))});var h=function(a,c){if(void 0!==e){var d=e;e=void 0}else{var b=f.genrand_res53();var g=f.genrand_res53();b=Math.sqrt(-2*Math.log(b));g*=2*Math.PI;d=b*Math.cos(g);e=b*Math.sin(g)}return a+c*d};b.gauss=new Sk.builtin.func(function(a,\nc){Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(c));a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);return new Sk.builtin.float_(h(a,c))});b.normalvariate=b.gauss;b.lognormvariate=new Sk.builtin.func(function(a,c){Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2);Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a));Sk.builtin.pyCheckType(\"sigma\",\n\"number\",Sk.builtin.checkNumber(c));a=Sk.builtin.asnum$(a);c=Sk.builtin.asnum$(c);return new Sk.builtin.float_(Math.exp(h(a,c)))});b.expovariate=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1);Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(a));a=Sk.builtin.asnum$(a);var c=f.genrand_res53();return new Sk.builtin.float_(-Math.log(c)/a)});b.choice=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1);Sk.builtin.pyCheckType(\"seq\",\n\"sequence\",Sk.builtin.checkSequence(a));if(void 0!==a.sq$length){var c=new Sk.builtin.int_(f.genrand_res53()*a.sq$length()|0);return a.mp$subscript(c)}throw new Sk.builtin.TypeError(\"object has no length\");});b.shuffle=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1);Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(a));if(a.constructor===Sk.builtin.list)for(var c=a.v,d=c.length-1;0<d;--d){var b=f.genrand_res53()*(d+1)|0,e=c[b];c[b]=c[d];c[d]=\ne}else if(void 0!==a.sq$length)if(void 0!==a.mp$ass_subscript)for(d=a.sq$length()-1;0<d;--d)b=new Sk.builtin.int_(f.genrand_res53()*(d+1)|0),d=new Sk.builtin.int_(d),e=a.mp$subscript(b),a.mp$ass_subscript(b,a.mp$subscript(d)),a.mp$ass_subscript(d,e);else throw new Sk.builtin.TypeError(\"object is immutable\");else throw new Sk.builtin.TypeError(\"object has no length\");return Sk.builtin.none.none$});b.sample=new Sk.builtin.func(function(a,c){var b;Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,\n2,2);Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(a));Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(c));c=Sk.builtin.asnum$(c);var e=[];var g=Sk.abstr.iter(a);var h=0;for(b=g.tp$iternext();void 0!==b;h++,b=g.tp$iternext()){var k=Math.floor(f.genrand_res53()*(h+1));h<c?(k<h&&(e[h]=e[k]),e[k]=b):k<c&&(e[k]=b)}if(h<c)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(e)});return b};\n",
  "src/lib/re.js": "var $builtinmodule=function(v){var c={__name__:new Sk.builtin.str(\"re\")};c.I=2;c.IGNORECASE=2;c.M=8;c.MULTILINE=8;var u=[\"(?:\",\"(?=\",\"(?!\"];var r=function(a){var b,e;if(b=a.match(/\\(\\?./g))for(e=0;e<b.length;e++)if(-1==u.indexOf(b[e]))throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"+b[e]+\"'\");a.replace(\"/\\\\/g\",\"\\\\\\\\\");return a.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\")};var t=function(a){var b=\"g\";(a&c.IGNORECASE)==c.IGNORECASE&&(b+=\"i\");(a&c.MULTILINE)==c.MULTILINE&&(b+=\"m\");return b};\nvar g=function(a,b,e,d){var f,k,c;Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,4);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===e&&(e=0);if(!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"maxsplit must be a number\");void 0===d&&(d=0);if(!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");e=Sk.builtin.asnum$(e);\nvar h=Sk.ffi.remapToJs(a);var l=Sk.ffi.remapToJs(b);h=r(h);var g=null!==h.match(/^\\(.*\\)$/);var m=t(d);h=new RegExp(h,m);m=[];f;for(c=k=0;null!=(f=h.exec(l))&&f.index!==h.lastIndex&&!(m.push(new Sk.builtin.str(l.substring(k,f.index))),g&&m.push(new Sk.builtin.str(f[0])),k=h.lastIndex,c+=1,e&&c>=e););m.push(new Sk.builtin.str(l.substring(k)));return new Sk.builtin.list(m)};g.co_varnames=[\"pattern\",\"string\",\"maxsplit\",\"flags\"];g.$defaults=[new Sk.builtin.int_(0),new Sk.builtin.int_(0)];c.split=new Sk.builtin.func(g);\nvar n=function(a,b,e){var d;Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,3);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===e&&(e=0);if(!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");var f=Sk.ffi.remapToJs(a);var k=Sk.ffi.remapToJs(b);f=r(f);var c=t(e);c=new RegExp(f,c);f.match(/\\$/)&&k.match(new RegExp(/\\n$/))&&(k=\nk.slice(0,-1));f=[];for(d;null!=(d=c.exec(k));){if(2>d.length)f.push(new Sk.builtin.str(d[0]));else if(2==d.length)f.push(new Sk.builtin.str(d[1]));else{for(var h=[],l=1;l<d.length;l++)h.push(new Sk.builtin.str(d[l]));f.push(new Sk.builtin.tuple(h))}d.index===c.lastIndex&&(c.lastIndex+=1)}return new Sk.builtin.list(f)};n.co_varnames=[\"pattern\",\"string\",\"flags\"];n.$defaults=[new Sk.builtin.int_(0)];c.findall=new Sk.builtin.func(n);c.MatchObject=Sk.misceval.buildClass(c,function(a,b){b.__init__=new Sk.builtin.func(function(a,\nd,b,c){a.thematch=d;a.re=b;a.string=c;return Sk.builtin.none.none$});b.groups=new Sk.builtin.func(function(a){a=a.thematch.v.slice(1);return new Sk.builtin.tuple(a)});b.group=new Sk.builtin.func(function(a,d){d=void 0===d?0:Sk.builtin.asnum$(d);if(d>=a.thematch.v.length)throw new Sk.builtin.IndexError(\"Index out of range: \"+d);return a.thematch.v[d]})},\"MatchObject\",[]);c._findre=function(a,b){a=a.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\");a=eval(a);b=Sk.ffi.remapToJs(b);b=b.match(/\\n$/)?b.slice(0,\n-1).match(a):b.match(a);var c=new Sk.builtin.list;if(null==b)return c;for(var d=0;d<b.length;++d)a=new Sk.builtin.str(b[d]),c.v.push(a);return c};var p=function(a,b,e){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,3);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");void 0===e&&(e=0);if(!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");\nvar d=\"/\"+a.v.replace(/\\//g,\"\\\\/\")+\"/\";d=c._findre(d,b);return 1>d.v.length?Sk.builtin.none.none$:Sk.misceval.callsimArray(c.MatchObject,[d,a,b])};p.co_varnames=[\"pattern\",\"string\",\"flags\"];p.$defaults=[new Sk.builtin.int_(0)];c.search=new Sk.builtin.func(p);var q=function(a,b,e){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,3);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");\nvoid 0===e&&(e=0);if(!Sk.builtin.checkNumber(e))throw new Sk.builtin.TypeError(\"flags must be a number\");var d=\"/^\"+Sk.ffi.remapToJs(a).replace(/\\//g,\"\\\\/\")+\"/\";d=c._findre(d,b);return 1>Sk.ffi.remapToJs(d).length?Sk.builtin.none.none$:Sk.misceval.callsimArray(c.MatchObject,[d,a,b])};q.co_varnames=[\"pattern\",\"string\",\"flags\"];q.$defaults=[new Sk.builtin.int_(0)];c.match=new Sk.builtin.func(q);c.RegexObject=Sk.misceval.buildClass(c,function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c){a.re=\nb;a.flags=void 0===c?0:c;return Sk.builtin.none.none$});a=new Sk.builtin.func(function(a){a=\"re.compile('\"+Sk.ffi.remapToJs(a.re)+\"')\";return Sk.ffi.remapToPy(a.substring(0,212))});b.__str__=a;b.__repr__=a;var c=function(a,b,c){a=Sk.ffi.remapToJs(a);b=void 0==b?0:Sk.ffi.remapToJs(b);c=void 0==c?a.length:Sk.ffi.remapToJs(c);\"^\"==b&&(b=a.indexOf(\"\\n\")+1);null===c&&(c=a.length);return Sk.ffi.remapToPy(a.substring(b,c))};a=function(a,b,e,g){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,4);var d=\nc(b,e,g);return p(a.re,d,a.flags)};a.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];a.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];b.search=new Sk.builtin.func(a);a=function(a,b,e,g){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,4);var d=c(b,e,g);return q(a.re,d,a.flags)};a.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];a.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];b.match=new Sk.builtin.func(a);a=function(a,b,c){Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,3);\nvoid 0===c&&(c=0);if(!Sk.builtin.checkInt(c))throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");return g(a.re,b,c,a.flags)};a.co_varnames=[\"self\",\"string\",\"maxsplit\"];a.$defaults=[new Sk.builtin.int_(0)];b.split=new Sk.builtin.func(a);a=function(a,b,e,g){Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,4);var d=c(b,e,g);return n(a.re,d,a.flags)};a.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"];a.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$];b.findall=new Sk.builtin.func(a)},\n\"RegexObject\",[]);c.compile=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"compile\",arguments.length,1,2);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");void 0===b&&(b=0);if(!Sk.builtin.checkNumber(b))throw new Sk.builtin.TypeError(\"flags must be a number\");return Sk.misceval.callsimArray(c.RegexObject,[a,b])});c.purge=new Sk.builtin.func(function(){});return c};\n",
  "src/lib/string.js": "var $builtinmodule=function(h){var a={};a.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.ascii_letters=new Sk.builtin.str(a.ascii_lowercase.v+a.ascii_uppercase.v);a.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\");a.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");a.letters=new Sk.builtin.str(a.lowercase.v+a.uppercase.v);a.digits=new Sk.builtin.str(\"0123456789\");a.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\");\na.octdigits=new Sk.builtin.str(\"01234567\");a.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\");a.whitespace=new Sk.builtin.str(\"\\t\\n\\x0B\\f\\r \");a.printable=new Sk.builtin.str(a.digits.v+a.letters.v+a.punctuation.v+\" \\t\\n\\r\\x0B\\f\");a.split=new Sk.builtin.func(function(a){for(var b=[],c=0;c<arguments.length;++c)b[c-0]=arguments[c];return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,b)});a.capitalize=new Sk.builtin.func(function(a){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,\n[a])});a.join=new Sk.builtin.func(function(a,b){void 0===b&&(b=new Sk.builtin.str(\" \"));return Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[b,a])});a.capwords=new Sk.builtin.func(function(e,b){Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2);if(!Sk.builtin.checkString(e))throw new Sk.builtin.TypeError(\"s must be a string\");void 0===b&&(b=new Sk.builtin.str(\" \"));if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var c=Sk.misceval.callsimArray(a.split,\n[e,b]).v,f=[],d=0;d<c.length;d++){var g=Sk.misceval.callsimArray(a.capitalize,[c[d]]);f.push(g)}return Sk.misceval.callsimArray(a.join,[new Sk.builtin.list(f),b])});return a};\n"
}